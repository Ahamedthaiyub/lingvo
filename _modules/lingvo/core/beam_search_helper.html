<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>lingvo.core.beam_search_helper &mdash; Lingvo  documentation</title>
      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../index.html" class="icon icon-home"> Lingvo
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../lingvo.html">lingvo package</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">Lingvo</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../../index.html">Module code</a> &raquo;</li>
      <li>lingvo.core.beam_search_helper</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for lingvo.core.beam_search_helper</h1><div class="highlight"><pre>
<span></span><span class="c1"># Lint as: python3</span>
<span class="c1"># Copyright 2018 The TensorFlow Authors. All Rights Reserved.</span>
<span class="c1">#</span>
<span class="c1"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="c1"># you may not use this file except in compliance with the License.</span>
<span class="c1"># You may obtain a copy of the License at</span>
<span class="c1">#</span>
<span class="c1">#     http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="c1">#</span>
<span class="c1"># Unless required by applicable law or agreed to in writing, software</span>
<span class="c1"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="c1"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="c1"># See the License for the specific language governing permissions and</span>
<span class="c1"># limitations under the License.</span>
<span class="c1"># ==============================================================================</span>
<span class="sd">&quot;&quot;&quot;Helper class for implementing a beam search decoder.</span>

<span class="sd">Individual models just need to provide a few callback functions.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">lingvo.compat</span> <span class="k">as</span> <span class="nn">tf</span>
<span class="kn">from</span> <span class="nn">lingvo.core</span> <span class="kn">import</span> <span class="n">base_layer</span>
<span class="kn">from</span> <span class="nn">lingvo.core</span> <span class="kn">import</span> <span class="n">ops</span>
<span class="kn">from</span> <span class="nn">lingvo.core</span> <span class="kn">import</span> <span class="n">py_utils</span>

<span class="kn">from</span> <span class="nn">tensorflow.python.ops</span> <span class="kn">import</span> <span class="n">inplace_ops</span>

<span class="c1"># TODO(yonghui):</span>
<span class="c1">#   1) Change the tensor shape [max_decoder_time_steps, batch_size *</span>
<span class="c1">#   num_hyps_per_beam] to [max_decoder_time_steps, num_hyps_per_beam,</span>
<span class="c1">#   batch_size] to avoid confusing and mis-interpretation of the results.</span>

<span class="c1"># Defines a namedtuple to store the results of BeamSearchDecode. It contains</span>
<span class="c1"># the following entries:</span>
<span class="c1">#  done_hyps: A string Tensor of shape</span>
<span class="c1">#    [max_decoder_time_steps, batch_size * num_hyps_per_beam] which can be</span>
<span class="c1">#    either an empty string, or a serialized Hypothesis proto. The non-empty</span>
<span class="c1">#    hyps in done_hyps are terminated hypotheses. The &#39;h&#39;-th hyp for sample</span>
<span class="c1">#    &#39;b&#39; at time step &#39;t&#39; can be found at done_hyps[t, batch_size * h + b].</span>
<span class="c1">#  topk_hyps: A string Tensor of shape [batch_size, num_hyps_per_beam].</span>
<span class="c1">#    topk_hyps[b, h] is the h-th hypothesis for the sample &#39;b&#39; in the</span>
<span class="c1">#    batch, which can either be an empty string or a serialized Hypothesis</span>
<span class="c1">#    proto.</span>
<span class="c1">#  topk_ids: Int32 Tensor of shape [batch_size * num_hyps_per_beam,</span>
<span class="c1">#    target_seq_len] which contains the IDs of the targets in each of the</span>
<span class="c1">#    hypotheses in the beam for the samples in the batch. For sample</span>
<span class="c1">#    &#39;b&#39; in the batch, the h-th hypothesis for this sample can be found at</span>
<span class="c1">#    position [b * num_hyps_per_beam + h, :].</span>
<span class="c1">#  topk_lens: Int32 Tensor of shape [batch_size * num_hyps_per_beam] which</span>
<span class="c1">#    indicates the length (&gt;=0) of each of the hypotheses.</span>
<span class="c1">#  topk_scores: Float32 Tensor of shape [batch_size, num_hyps_per_beam]</span>
<span class="c1">#    containing the scores (negative log probabilities) of each of the</span>
<span class="c1">#    hypotheses in the beam.</span>
<span class="c1">#  topk_decoded: A string Tensor of shape [batch_size * num_hyps_per_beam] which</span>
<span class="c1">#    contains the decoded target strings in each of the hypotheses in the</span>
<span class="c1">#    beam for the samples in the batch. The &#39;h&#39;-th hyp for sample &#39;b&#39; can</span>
<span class="c1">#    be found at topk_decoded[b * num_hyps_per_beam + h]</span>
<span class="n">BeamSearchDecodeOutput</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">namedtuple</span><span class="p">(</span>
    <span class="s1">&#39;BeamSearchDecodeOutput&#39;</span><span class="p">,</span>
    <span class="p">[</span>
        <span class="s1">&#39;topk_hyps&#39;</span><span class="p">,</span> <span class="s1">&#39;topk_ids&#39;</span><span class="p">,</span> <span class="s1">&#39;topk_lens&#39;</span><span class="p">,</span> <span class="s1">&#39;topk_scores&#39;</span><span class="p">,</span> <span class="s1">&#39;topk_decoded&#39;</span><span class="p">,</span>
        <span class="s1">&#39;other_states&#39;</span>
    <span class="p">],</span>
<span class="p">)</span>
<span class="c1"># Make the last attribute default to None.</span>
<span class="n">BeamSearchDecodeOutput</span><span class="o">.</span><span class="fm">__new__</span><span class="o">.</span><span class="vm">__defaults__</span> <span class="o">=</span> <span class="p">(</span><span class="kc">None</span><span class="p">,)</span>


<span class="c1"># Keys in fusion state that can be two dimensional, with the batch element in</span>
<span class="c1"># the second dimension, requiring special treatment in hypothesis reordering.</span>
<span class="n">POSSIBLY_TIME_MAJOR_STATE_KEYS</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s1">&#39;misc_states.fusion_states.lm_states.prev_ids&#39;</span><span class="p">,</span>
    <span class="s1">&#39;misc_states.fusion_states.lm_states.prev_paddings&#39;</span><span class="p">,</span>
    <span class="s1">&#39;fusion_states.lm_states.prev_ids&#39;</span><span class="p">,</span>
    <span class="s1">&#39;fusion_states.lm_states.prev_paddings&#39;</span><span class="p">,</span>
<span class="p">]</span>


<div class="viewcode-block" id="BeamSearchSharedParams"><a class="viewcode-back" href="../../../lingvo.core.beam_search_helper.html#lingvo.core.beam_search_helper.BeamSearchSharedParams">[docs]</a><span class="k">class</span> <span class="nc">BeamSearchSharedParams</span><span class="p">(</span><span class="n">base_layer</span><span class="o">.</span><span class="n">BaseLayer</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Class defining common beam search params.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="BeamSearchSharedParams.Params"><a class="viewcode-back" href="../../../lingvo.core.beam_search_helper.html#lingvo.core.beam_search_helper.BeamSearchSharedParams.Params">[docs]</a>  <span class="nd">@classmethod</span>
  <span class="k">def</span> <span class="nf">Params</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
    <span class="n">p</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">Params</span><span class="p">()</span>
    <span class="n">p</span><span class="o">.</span><span class="n">Define</span><span class="p">(</span><span class="s1">&#39;num_hyps_per_beam&#39;</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span>
             <span class="s1">&#39;Num of hyps to keep per beam during decoding.&#39;</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">Define</span><span class="p">(</span>
        <span class="s1">&#39;target_seq_length_ratio&#39;</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span>
        <span class="s1">&#39;Ratio of the average target sequence length over the average &#39;</span>
        <span class="s1">&#39;source sequence length. Affects coverage penalty.&#39;</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">Define</span><span class="p">(</span>
        <span class="s1">&#39;length_normalization&#39;</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span>
        <span class="s1">&#39;Beam search length normalization factor, typically in [0, 1]. &#39;</span>
        <span class="s1">&#39;This is the exponent on (len+5)/5 used to normalize &#39;</span>
        <span class="s1">&#39;global score. The larger this value is, the more likely &#39;</span>
        <span class="s1">&#39;longer sequences are produced. This value is alpha &#39;</span>
        <span class="s1">&#39;in https://arxiv.org/abs/1609.08144, equation 14.&#39;</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">Define</span><span class="p">(</span>
        <span class="s1">&#39;coverage_penalty&#39;</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span>
        <span class="s1">&#39;Beam search coverage penalty. This value is beta in &#39;</span>
        <span class="s1">&#39;https://arxiv.org/abs/1609.08144, equation 14. The higher this &#39;</span>
        <span class="s1">&#39;value is, the more heavily low coverage is penalized.&#39;</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">Define</span><span class="p">(</span>
        <span class="s1">&#39;valid_eos_max_logit_delta&#39;</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">,</span>
        <span class="s1">&#39;During beam search, allow &lt;/s&gt; to terminate a hyp only if its &#39;</span>
        <span class="s1">&#39;logit is no more than than this value away from the logit of the &#39;</span>
        <span class="s1">&#39;best candidate. The larger this value is, the easier hyps can &#39;</span>
        <span class="s1">&#39;terminate, and the more likely shorter sequences are produced.&#39;</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">Define</span><span class="p">(</span>
        <span class="s1">&#39;local_eos_threshold&#39;</span><span class="p">,</span> <span class="o">-</span><span class="mf">100.0</span><span class="p">,</span>
        <span class="s1">&#39;During beam search, allow &lt;/s&gt; to terminate a hyp if the local score &#39;</span>
        <span class="s1">&#39;for &lt;/s&gt; is greater than local_eos_threshold.&#39;</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">Define</span><span class="p">(</span>
        <span class="s1">&#39;beam_size&#39;</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">,</span>
        <span class="s1">&#39;The maximum difference between best hyp and the worst in a beam.&#39;</span>
        <span class="s1">&#39; This allows to prune our search when none of the active hyp is&#39;</span>
        <span class="s1">&#39; close enough to the current best.&#39;</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">Define</span><span class="p">(</span><span class="s1">&#39;target_sos_id&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;Id of the start of sentence token.&#39;</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">Define</span><span class="p">(</span><span class="s1">&#39;target_eos_id&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;Id of the end of sentence token.&#39;</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">Define</span><span class="p">(</span>
        <span class="s1">&#39;target_eoc_id&#39;</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
        <span class="s1">&#39;Id of the end of chunk token. Used by neural transducer only.&#39;</span>
        <span class="s1">&#39; Set this id to a non-negative value only for NT.&#39;</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">Define</span><span class="p">(</span>
        <span class="s1">&#39;target_seq_len&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;Maximum allowed target seq length. Note &#39;</span>
        <span class="s1">&#39;this parameter is often used to determine the maximum number of &#39;</span>
        <span class="s1">&#39;decode steps. For example, for the LAS model which does not uses eoc, &#39;</span>
        <span class="s1">&#39;decoding terminates if an end of sentence (eos) token is not emitted &#39;</span>
        <span class="s1">&#39;after target_seq_len decode steps. For the RNN-T model which does use &#39;</span>
        <span class="s1">&#39;eoc, decoding terminates if an terminal token (eos or last frame eoc) &#39;</span>
        <span class="s1">&#39;is not emitted after source_seq_len + target_seq_len.&#39;</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">Define</span><span class="p">(</span>
        <span class="s1">&#39;merge_paths&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="s1">&#39;If true, hyps which are identical when &#39;</span>
        <span class="s1">&#39;epsilons are removed will be combined into a single hyp.  The &#39;</span>
        <span class="s1">&#39;probability for that combined hyp will be the sum of the &#39;</span>
        <span class="s1">&#39;probabilities of the component hyps.  This can only be applied &#39;</span>
        <span class="s1">&#39;for epsilon-emitting models (RNN-T and NT).&#39;</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">Define</span><span class="p">(</span>
        <span class="s1">&#39;force_eos_in_top_k&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span>
        <span class="s1">&#39;Whether to always consider the eos token to be among the top k tokens &#39;</span>
        <span class="s1">&#39;for every step. When False, hyps can only terminate if the eos token &#39;</span>
        <span class="s1">&#39;is part of the top k. Note that p.valid_eos_max_logit_delta and &#39;</span>
        <span class="s1">&#39;p.local_eos_threshold always apply regardless of this.&#39;</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">Define</span><span class="p">(</span>
        <span class="s1">&#39;batch_major_state&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="s1">&#39;If True, we use batch as the major &#39;</span>
        <span class="s1">&#39;dimension of the hyp states. Otherwise, timing becomes the major &#39;</span>
        <span class="s1">&#39;dimension, and the gathers are performed along the second-to-major &#39;</span>
        <span class="s1">&#39;dimension.&#39;</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">Define</span><span class="p">(</span>
        <span class="s1">&#39;batch_major_compute&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="s1">&#39;If True, the target batch dimension &#39;</span>
        <span class="s1">&#39;is organized as num_beams by num_hyps_per_beam during the &#39;</span>
        <span class="s1">&#39;ExtendStep computation and the cache is stored following this order. &#39;</span>
        <span class="s1">&#39;So the topk indices into the cache for ReOrderHyps needs to be &#39;</span>
        <span class="s1">&#39;reordered before usage. Otherwise, the indices will be directly used &#39;</span>
        <span class="s1">&#39;without extra transformation. &#39;</span>
        <span class="s1">&#39;Setting batch_major_compute=True does not change the ordering of &#39;</span>
        <span class="s1">&#39;ids and logits of beam search callbacks. &#39;</span>
        <span class="s1">&#39;The target_batch dim for those tensors will remain num_hyps_per_beam &#39;</span>
        <span class="s1">&#39;* num_beams.&#39;</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">Define</span><span class="p">(</span>
        <span class="s1">&#39;short_seq_limit&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
        <span class="s1">&#39;An integer, the sequence length limit for using early stop &#39;</span>
        <span class="s1">&#39;method in attention layer (batch-major implementation). The sequence &#39;</span>
        <span class="s1">&#39;is always treated as the default long sequence for decoding when the &#39;</span>
        <span class="s1">&#39;limit is set to 0. For typical mt transformer config &#39;</span>
        <span class="s1">&#39;(batch 16, sequence length 150), the break even point is around 40 &#39;</span>
        <span class="s1">&#39;on TPU V3, and 50 on TPU V2. This may slightly change for &#39;</span>
        <span class="s1">&#39;different batch size and sequence length, which requires more &#39;</span>
        <span class="s1">&#39;experiments to set the value.&#39;</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">Define</span><span class="p">(</span>
        <span class="s1">&#39;terminate_beams_independently&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span>
        <span class="s1">&#39;Whether each beam in the same batch can independently terminate. &#39;</span>
        <span class="s1">&#39;This controls whether the search termination criteria set by params &#39;</span>
        <span class="s1">&#39;like `p.beam_size` or `p.ensure_full_beam` are applied collectively &#39;</span>
        <span class="s1">&#39;to all beams, or individually to each beam. When False, all beams &#39;</span>
        <span class="s1">&#39;continue the search until each and every beam meets the termination &#39;</span>
        <span class="s1">&#39;criteria. When True, each beam individually, independent of each &#39;</span>
        <span class="s1">&#39;other, decides whether to terminate the search.&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">p</span></div></div>


<div class="viewcode-block" id="BeamSearchHelper"><a class="viewcode-back" href="../../../lingvo.core.beam_search_helper.html#lingvo.core.beam_search_helper.BeamSearchHelper">[docs]</a><span class="k">class</span> <span class="nc">BeamSearchHelper</span><span class="p">(</span><span class="n">BeamSearchSharedParams</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Helper class for performing beam search.</span>

<span class="sd">  The user of this helper class needs to implement three callbacks.</span>

<span class="sd">  This callback is called once only at the beginning of beam search:</span>

<span class="sd">  .. code-block:: none</span>

<span class="sd">      def InitBeamSearchState(theta, encoder_outputs, num_hyps_per_beam):</span>
<span class="sd">        Args:</span>
<span class="sd">          theta: A NestedMap object containing weights&#39; values of this layer and</span>
<span class="sd">            its children layers.</span>
<span class="sd">          encoder_outputs: A NestedMap computed by encoder.</span>
<span class="sd">          num_hyps_per_beam: An int, number hyps to keep for source sentence.</span>

<span class="sd">        Returns:</span>
<span class="sd">          A tuple (initial_results, states):</span>

<span class="sd">          - initial_results: a `.NestedMap` of initial results. It must contain</span>
<span class="sd">            the &#39;atten_probs&#39; and &#39;log_probs&#39; tensors. Optionally it may</span>
<span class="sd">            contain &#39;step_ids&#39;.</span>

<span class="sd">            - log_probs: The initial log probs for each of the tokens in the</span>
<span class="sd">              target vocab of shape [num_hyps_per_beam * src_batch, vocab_size].</span>
<span class="sd">              src_batch &quot;b&quot; and hyp_per_beam &quot;h&quot; is represented at index</span>
<span class="sd">              ``(h * src_batch + b)``.</span>
<span class="sd">            - atten_probs: The initial attention probs, of shape</span>
<span class="sd">              [num_hyps_per_beam * src_batch, src_len]. src_batch &quot;b&quot; and</span>
<span class="sd">              hyp_per_beam &quot;h&quot; is represented at index ``(h * src_batch + b)``.</span>
<span class="sd">            - step_ids: Optional. The initial ids of shape [num_hyps_per_beam *</span>
<span class="sd">              src_batch, 1] for which to start the beam search. src_batch &quot;b&quot;</span>
<span class="sd">              hyp_per_beam &quot;h&quot; is represented at index ``(h * src_batch + b)``.</span>
<span class="sd">              If not specified, defaults to a tensor filled with target_sos_id.</span>

<span class="sd">          - states: a `.NestedMap` of tensors representing states that the</span>
<span class="sd">            client would like to keep track of for each hyp.</span>

<span class="sd">  This callback is called once every decoding time step before beam_search_step</span>
<span class="sd">  is called:</span>

<span class="sd">  .. code-block:: none</span>

<span class="sd">      def PreBeamSearchStepCallback(theta,</span>
<span class="sd">                                    encoder_outputs,</span>
<span class="sd">                                    step_ids,</span>
<span class="sd">                                    in_states,</span>
<span class="sd">                                    num_hyps_per_beam):</span>
<span class="sd">        Args:</span>
<span class="sd">          theta: A NestedMap object containing weights&#39; values of this layer and</span>
<span class="sd">            its children layers.</span>
<span class="sd">          encoder_outputs: A NestedMap computed by encoder.</span>
<span class="sd">          step_ids: A tensor of shape [num_hyps_per_beam * src_batch, 1].</span>
<span class="sd">          in_states: A `.NestedMap` of tensors representing states that the</span>
<span class="sd">            clients would like to keep track of for each of the active hyps.</span>

<span class="sd">        Returns:</span>
<span class="sd">          A tuple (results, out_states):</span>

<span class="sd">          - results: A `.NestedMap` of beam search results. It should contain</span>
<span class="sd">            the &#39;atten_probs&#39; and &#39;log_probs&#39; tensors at the minimal.</span>
<span class="sd">            Optionally it may contain &#39;is_last_chunk&#39; if it is decoding a</span>
<span class="sd">            neural transducer model.</span>

<span class="sd">            - atten_probs: The updated attention probs, of shape</span>
<span class="sd">              [num_hyps_per_beam * src_batch, src_len]. src_batch &quot;b&quot; and</span>
<span class="sd">              hyp_per_beam &quot;h&quot; is represented at index ``(h * src_batch + b)``.</span>
<span class="sd">            - log_probs: Log prob for each of the tokens in the target vocab.</span>
<span class="sd">              This is of shape [num_hyps_per_beam * src_batch, vocab_size].</span>
<span class="sd">              src_batch &quot;b&quot; and hyp_per_beam &quot;h&quot; is represented at index</span>
<span class="sd">              ``(h * src_batch + b)``.</span>
<span class="sd">            - is_last_chunk: Whether each of the hyp is at the end of a chunk.</span>
<span class="sd">              If non-empty, it has shape [num_hyps_per_beam * src_batch, 1].</span>

<span class="sd">          - out_states: A `.NestedMap`. The updated states. This &#39;out_states&#39;</span>
<span class="sd">            should be of the exact same structure as &#39;in_states&#39;</span>

<span class="sd">  This callback is called once every decoding time step after beam_search_step</span>
<span class="sd">  is called:</span>

<span class="sd">  .. code-block:: none</span>

<span class="sd">      def PostBeamSearchStepCallback(theta,</span>
<span class="sd">                                     encoder_outputs,</span>
<span class="sd">                                     new_step_ids,</span>
<span class="sd">                                     other_states):</span>
<span class="sd">        Args:</span>
<span class="sd">          theta: A NestedMap object containing weights&#39; values of this layer and</span>
<span class="sd">            its children layers.</span>
<span class="sd">          encoder_outputs: A NestedMap computed by encoder.</span>
<span class="sd">          new_step_ids: Token ids for the next beam search step.</span>
<span class="sd">          other_states: A `.NestedMap`.</span>

<span class="sd">        Returns:</span>
<span class="sd">          final_states, A `.NestedMap`.</span>
<span class="sd">  &quot;&quot;&quot;</span>

<div class="viewcode-block" id="BeamSearchHelper.Params"><a class="viewcode-back" href="../../../lingvo.core.beam_search_helper.html#lingvo.core.beam_search_helper.BeamSearchHelper.Params">[docs]</a>  <span class="nd">@classmethod</span>
  <span class="k">def</span> <span class="nf">Params</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
    <span class="n">p</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">Params</span><span class="p">()</span>
    <span class="n">p</span><span class="o">.</span><span class="n">Define</span><span class="p">(</span>
        <span class="s1">&#39;allow_empty_terminated_hyp&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="s1">&#39;Whether it is okay to consider a &#39;</span>
        <span class="s1">&#39;hyp that consists only of epsilons as terminated.  By default this &#39;</span>
        <span class="s1">&#39;is true, as an utterance may consist of silence.  It should be set &#39;</span>
        <span class="s1">&#39;to false when EMBR training epsilon-emitting models (e.g., RNN-T), &#39;</span>
        <span class="s1">&#39;which are prone to emit all-epsilon hyps even in the presence of &#39;</span>
        <span class="s1">&#39;speech.  Note that a hyp that terminates in EOS is not considered &#39;</span>
        <span class="s1">&#39;empty, so this flag has no effect for non-epsilon-emitting models.&#39;</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">Define</span><span class="p">(</span>
        <span class="s1">&#39;ensure_full_beam&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="s1">&#39;If True, we will not terminate the search &#39;</span>
        <span class="s1">&#39;until both of these conditions are satisfied: we have found at least &#39;</span>
        <span class="s1">&#39;num_hyps_per_beam terminated hyps AND no active hyps have a score &#39;</span>
        <span class="s1">&#39;within beam_size of the best terminated hyp.  If False, only the &#39;</span>
        <span class="s1">&#39;second condition must be satisfied.  Note that in either case, we can &#39;</span>
        <span class="s1">&#39;also terminate if we have run for target_seq_len steps.  Generally &#39;</span>
        <span class="s1">&#39;this should be False unless beam search is being run as part of &#39;</span>
        <span class="s1">&#39;minimum word error rate training.&#39;</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">Define</span><span class="p">(</span>
        <span class="s1">&#39;force_eos_in_last_step&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span>
        <span class="s1">&#39;For all active hyps that are still on the beam after target_seq_len &#39;</span>
        <span class="s1">&#39;steps, return partial hyps with EOS set as the last token.&#39;</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">Define</span><span class="p">(</span>
        <span class="s1">&#39;atten_vecs_in_hypothesis_protos&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span>
        <span class="s1">&#39;Whether to write atten_vecs fields in the Hypothesis protos. Setting &#39;</span>
        <span class="s1">&#39;this to False saves memory, and can be used when the protos become &#39;</span>
        <span class="s1">&#39;too large for long sequences, but requires p.coverage_penalty == 0.0.&#39;</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">Define</span><span class="p">(</span>
        <span class="s1">&#39;force_last_chunk_eoc_in_top_k&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span>
        <span class="s1">&#39;Whether to always consider the last chunk eoc token to be among the &#39;</span>
        <span class="s1">&#39;top k tokens. This is effective only when decoding has reached the &#39;</span>
        <span class="s1">&#39;last frame of input. When True, hyps can terminate at the last frame &#39;</span>
        <span class="s1">&#39;by eoc even if the eoc score is not high enough to enter the top k. &#39;</span>
        <span class="s1">&#39;Note that p.valid_eos_max_logit_delta and p.local_eos_threshold &#39;</span>
        <span class="s1">&#39;always apply regardless of this.&#39;</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">Define</span><span class="p">(</span>
        <span class="s1">&#39;merged_topk_buffer_size_factor&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span>
        <span class="s1">&#39;The buffer size factor when pruning the per hyp top-k extensions to &#39;</span>
        <span class="s1">&#39;form the per beam top-k extensions. If this factor is set to greater &#39;</span>
        <span class="s1">&#39;than or equal num_hyps_per_beam + 2 when eoc_id &gt;= 0, there will be &#39;</span>
        <span class="s1">&#39;no pruning before all possible path mergings are performed (if &#39;</span>
        <span class="s1">&#39;merge_paths=True). To be memory efficient (i.e., to maintain less &#39;</span>
        <span class="s1">&#39;hyps during pruning), a reasonable value is 2.&#39;</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;beam_search&#39;</span>
    <span class="k">return</span> <span class="n">p</span></div>

  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
    <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
    <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_model_uses_eoc_id</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">target_eoc_id</span> <span class="o">&gt;=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">p</span><span class="o">.</span><span class="n">atten_vecs_in_hypothesis_protos</span> <span class="ow">and</span> <span class="n">p</span><span class="o">.</span><span class="n">coverage_penalty</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;p.atten_vecs_in_hypothesis_protos requires &#39;</span>
                       <span class="s1">&#39;p.coverage_penalty == 0.0.&#39;</span><span class="p">)</span>

<div class="viewcode-block" id="BeamSearchHelper._BeamSearchStep"><a class="viewcode-back" href="../../../lingvo.core.beam_search_helper.html#lingvo.core.beam_search_helper.BeamSearchHelper._BeamSearchStep">[docs]</a>  <span class="k">def</span> <span class="nf">_BeamSearchStep</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">encoder_outputs</span><span class="p">,</span> <span class="n">cur_step</span><span class="p">,</span> <span class="n">step_ids</span><span class="p">,</span>
                      <span class="n">core_bs_states</span><span class="p">,</span> <span class="n">other_states</span><span class="p">,</span> <span class="n">num_hyps_per_beam</span><span class="p">,</span>
                      <span class="n">pre_beam_search_step_callback</span><span class="p">,</span>
                      <span class="n">post_beam_search_step_callback</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Extend beam search hyps for one step.</span>

<span class="sd">      | num_beams = Number of source sequences to be decoded.</span>
<span class="sd">      | num_hyps_per_beam = Number of hyps to keep per source sequence.</span>
<span class="sd">      | num_hyps = num_beams * num_hyps_per_beam</span>
<span class="sd">      | src_seq_len = Number of time steps in the source sequence.</span>
<span class="sd">      | src_batch = Number of examples in the source sequence.</span>
<span class="sd">      | tgt_seq_len = Maximum allowed time steps in the target sequence.</span>
<span class="sd">      | tgt_batch = num_hyps_per_beam * src_batch</span>

<span class="sd">    Args:</span>
<span class="sd">      theta: A `.NestedMap` object containing weights&#39; values of the decoder</span>
<span class="sd">        layer and its children layers.</span>
<span class="sd">      encoder_outputs: A `.NestedMap` containing encoder outputs to be passed to</span>
<span class="sd">        the callbacks.</span>
<span class="sd">      cur_step: A scalar int tensor, the current time step, 0-based.</span>
<span class="sd">      step_ids: An int tensor of shape [num_hyps, 1]. The input ids to the</span>
<span class="sd">        current search step.</span>
<span class="sd">      core_bs_states: A tuple of core beam search states. This list is</span>
<span class="sd">        maintained by this helper class.</span>
<span class="sd">      other_states: A `.NestedMap` of other beam search states. This</span>
<span class="sd">        `.NestedMap` is managed and updated by the client. It is expected that</span>
<span class="sd">        each of its member tensors are of rank &gt;= 1. t[i, ...] is the state of</span>
<span class="sd">        the i-th hyp at the beginning of this search step.</span>
<span class="sd">      num_hyps_per_beam: Num of hyps to keep per beam.</span>
<span class="sd">      pre_beam_search_step_callback: The `PreBeamSearchStepCallback` callback.</span>
<span class="sd">        See class header comments for more details.</span>
<span class="sd">      post_beam_search_step_callback: The `PostBeamSearchStepCallback` callback.</span>
<span class="sd">        See class header comments for more details.</span>

<span class="sd">    Returns:</span>
<span class="sd">      A tuple of following elements for the next beam search step,</span>
<span class="sd">      (next step, all_done, step_ids, core_bs_states, other_states)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span>

    <span class="n">bs_results</span><span class="p">,</span> <span class="n">other_states</span> <span class="o">=</span> <span class="n">pre_beam_search_step_callback</span><span class="p">(</span>
        <span class="n">theta</span><span class="p">,</span> <span class="n">encoder_outputs</span><span class="p">,</span> <span class="n">step_ids</span><span class="p">,</span> <span class="n">other_states</span><span class="p">,</span> <span class="n">num_hyps_per_beam</span><span class="p">)</span>

    <span class="p">(</span><span class="n">best_scores</span><span class="p">,</span> <span class="n">cumulative_scores</span><span class="p">,</span> <span class="n">in_scores</span><span class="p">,</span> <span class="n">in_hyps</span><span class="p">,</span> <span class="n">in_prev_hyps</span><span class="p">,</span>
     <span class="n">in_done_hyps</span><span class="p">,</span> <span class="n">in_atten_probs</span><span class="p">,</span> <span class="n">in_beam_done</span><span class="p">)</span> <span class="o">=</span> <span class="n">core_bs_states</span>

    <span class="p">(</span><span class="n">out_best_scores</span><span class="p">,</span> <span class="n">out_cumulative_scores</span><span class="p">,</span> <span class="n">out_scores</span><span class="p">,</span> <span class="n">out_hyps</span><span class="p">,</span>
     <span class="n">out_prev_hyps</span><span class="p">,</span> <span class="n">out_done_hyps</span><span class="p">,</span> <span class="n">out_atten_probs</span><span class="p">,</span> <span class="n">out_beam_done</span><span class="p">,</span>
     <span class="n">all_done</span><span class="p">)</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">beam_search_step</span><span class="p">(</span>
         <span class="n">tf</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">bs_results</span><span class="o">.</span><span class="n">log_probs</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">p</span><span class="o">.</span><span class="n">dtype</span><span class="p">),</span>
         <span class="n">tf</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">bs_results</span><span class="o">.</span><span class="n">atten_probs</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">p</span><span class="o">.</span><span class="n">dtype</span><span class="p">),</span>
         <span class="n">best_scores</span><span class="p">,</span>
         <span class="n">cumulative_scores</span><span class="p">,</span>
         <span class="n">in_scores</span><span class="p">,</span>
         <span class="n">in_hyps</span><span class="p">,</span>
         <span class="n">in_prev_hyps</span><span class="p">,</span>
         <span class="n">in_done_hyps</span><span class="p">,</span>
         <span class="n">in_atten_probs</span><span class="p">,</span>
         <span class="n">in_beam_done</span><span class="p">,</span>
         <span class="n">bs_results</span><span class="o">.</span><span class="n">is_last_chunk</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model_uses_eoc_id</span> <span class="k">else</span> <span class="p">[],</span>
         <span class="n">cur_step</span><span class="p">,</span>
         <span class="n">eoc_id</span><span class="o">=</span><span class="n">p</span><span class="o">.</span><span class="n">target_eoc_id</span><span class="p">,</span>
         <span class="n">eos_id</span><span class="o">=</span><span class="n">p</span><span class="o">.</span><span class="n">target_eos_id</span><span class="p">,</span>
         <span class="n">beam_size</span><span class="o">=</span><span class="n">p</span><span class="o">.</span><span class="n">beam_size</span><span class="p">,</span>
         <span class="n">num_hyps_per_beam</span><span class="o">=</span><span class="n">num_hyps_per_beam</span><span class="p">,</span>
         <span class="n">valid_eos_max_logit_delta</span><span class="o">=</span><span class="n">p</span><span class="o">.</span><span class="n">valid_eos_max_logit_delta</span><span class="p">,</span>
         <span class="n">merge_paths</span><span class="o">=</span><span class="n">p</span><span class="o">.</span><span class="n">merge_paths</span><span class="p">,</span>
         <span class="n">allow_empty_terminated_hyp</span><span class="o">=</span><span class="n">p</span><span class="o">.</span><span class="n">allow_empty_terminated_hyp</span><span class="p">,</span>
         <span class="n">ensure_full_beam</span><span class="o">=</span><span class="n">p</span><span class="o">.</span><span class="n">ensure_full_beam</span><span class="p">,</span>
         <span class="n">force_eos_in_last_step</span><span class="o">=</span><span class="n">p</span><span class="o">.</span><span class="n">force_eos_in_last_step</span><span class="p">,</span>
         <span class="n">force_eos_in_top_k</span><span class="o">=</span><span class="n">p</span><span class="o">.</span><span class="n">force_eos_in_top_k</span><span class="p">,</span>
         <span class="n">force_last_chunk_eoc_in_top_k</span><span class="o">=</span><span class="n">p</span><span class="o">.</span><span class="n">force_last_chunk_eoc_in_top_k</span><span class="p">,</span>
         <span class="n">merged_topk_buffer_size_factor</span><span class="o">=</span><span class="n">p</span><span class="o">.</span><span class="n">merged_topk_buffer_size_factor</span><span class="p">,</span>
         <span class="n">local_eos_threshold</span><span class="o">=</span><span class="n">p</span><span class="o">.</span><span class="n">local_eos_threshold</span><span class="p">,</span>
         <span class="n">beam_independence</span><span class="o">=</span><span class="n">p</span><span class="o">.</span><span class="n">terminate_beams_independently</span><span class="p">,</span>
         <span class="n">atten_vecs_in_hypothesis_protos</span><span class="o">=</span><span class="n">p</span><span class="o">.</span><span class="n">atten_vecs_in_hypothesis_protos</span><span class="p">)</span>

    <span class="n">new_step_ids</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">out_hyps</span><span class="p">[</span><span class="n">cur_step</span><span class="p">,</span> <span class="p">:],</span> <span class="n">tf</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">step_ids</span><span class="p">))</span>
    <span class="n">new_step_ids</span><span class="o">.</span><span class="n">set_shape</span><span class="p">(</span><span class="n">step_ids</span><span class="o">.</span><span class="n">get_shape</span><span class="p">())</span>

    <span class="c1"># [num_hyps_per_beam * num_beams].</span>
    <span class="n">old_hyp_ids</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
        <span class="n">tf</span><span class="o">.</span><span class="n">slice</span><span class="p">(</span><span class="n">out_prev_hyps</span><span class="p">,</span> <span class="n">begin</span><span class="o">=</span><span class="p">[</span><span class="n">cur_step</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">size</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">batch_major_compute</span><span class="p">:</span>
      <span class="c1"># Transformed the indices into the key/value cache for fast decoding</span>
      <span class="c1"># (prefix_states in other_states) due to the num_hyps dimension of</span>
      <span class="c1"># cache is computed as num_beams by num_hyps_per_beam, which is different</span>
      <span class="c1"># from the old_hyp_ids assumption (num_hyps_per_beam by num_beams).</span>
      <span class="c1"># Both transpose and recomputation are required to correct the indices.</span>
      <span class="n">num_beams</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">best_scores</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
      <span class="c1"># [num_beams * num_hyps_per_beam].</span>
      <span class="n">old_hyp_ids_in_cache_order</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
          <span class="n">tf</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">old_hyp_ids</span><span class="p">,</span> <span class="p">[</span><span class="n">num_hyps_per_beam</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])),</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
      <span class="n">old_hyp_ids_in_cache_order</span> <span class="o">=</span> <span class="p">(</span>
          <span class="p">(</span><span class="n">old_hyp_ids_in_cache_order</span> <span class="o">%</span> <span class="n">num_beams</span><span class="p">)</span> <span class="o">*</span> <span class="n">num_hyps_per_beam</span> <span class="o">+</span>
          <span class="n">old_hyp_ids_in_cache_order</span> <span class="o">//</span> <span class="n">num_beams</span><span class="p">)</span>

    <span class="n">new_bs_states</span> <span class="o">=</span> <span class="p">(</span><span class="n">out_best_scores</span><span class="p">,</span> <span class="n">out_cumulative_scores</span><span class="p">,</span> <span class="n">out_scores</span><span class="p">,</span>
                     <span class="n">out_hyps</span><span class="p">,</span> <span class="n">out_prev_hyps</span><span class="p">,</span> <span class="n">out_done_hyps</span><span class="p">,</span> <span class="n">out_atten_probs</span><span class="p">,</span>
                     <span class="n">out_beam_done</span><span class="p">)</span>
    <span class="n">random_seed_regex</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;rnn_states\[\d+\].r$&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ReOrderHyps</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">x_in</span><span class="p">):</span>
      <span class="sd">&quot;&quot;&quot;Reorders x_in based on prev hyp ids.&quot;&quot;&quot;</span>
      <span class="k">if</span> <span class="n">random_seed_regex</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
        <span class="c1"># For keys like rnn_states[0].r, it is a shape [2] random seeds tensor</span>
        <span class="c1"># used for deterministic behavior and should not be reordered.</span>
        <span class="k">return</span> <span class="n">py_utils</span><span class="o">.</span><span class="n">HasShape</span><span class="p">(</span><span class="n">x_in</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="p">])</span>
      <span class="n">correct_old_hyp_ids</span> <span class="o">=</span> <span class="p">(</span>
          <span class="n">old_hyp_ids_in_cache_order</span> <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">batch_major_compute</span> <span class="k">else</span> <span class="n">old_hyp_ids</span><span class="p">)</span>
      <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">x_in</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">)</span> <span class="ow">and</span> <span class="n">x_in</span><span class="o">.</span><span class="n">shape</span><span class="o">.</span><span class="n">ndims</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">x_in</span><span class="o">.</span><span class="n">shape</span><span class="o">.</span><span class="n">ndims</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">p</span><span class="o">.</span><span class="n">batch_major_state</span><span class="p">:</span>
          <span class="c1"># Use corrected indices only here for batch major compute as key/value</span>
          <span class="c1"># caches are the states being affected.</span>
          <span class="n">x_out</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">x_in</span><span class="p">,</span> <span class="n">correct_old_hyp_ids</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">POSSIBLY_TIME_MAJOR_STATE_KEYS</span><span class="p">:</span>
          <span class="n">x_out</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">x_in</span><span class="p">,</span> <span class="n">old_hyp_ids</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="n">x_out</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">x_in</span><span class="p">,</span> <span class="n">correct_old_hyp_ids</span><span class="p">)</span>
        <span class="n">x_out</span><span class="o">.</span><span class="n">set_shape</span><span class="p">(</span><span class="n">x_in</span><span class="o">.</span><span class="n">get_shape</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">x_out</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">x_in</span>

    <span class="n">new_other_states</span> <span class="o">=</span> <span class="n">other_states</span><span class="o">.</span><span class="n">TransformWithKey</span><span class="p">(</span><span class="n">ReOrderHyps</span><span class="p">)</span>

    <span class="n">final_other_states</span> <span class="o">=</span> <span class="n">post_beam_search_step_callback</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">encoder_outputs</span><span class="p">,</span>
                                                        <span class="n">new_step_ids</span><span class="p">,</span>
                                                        <span class="n">new_other_states</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">cur_step</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">all_done</span><span class="p">,</span> <span class="n">new_step_ids</span><span class="p">,</span> <span class="n">new_bs_states</span><span class="p">,</span>
            <span class="n">final_other_states</span><span class="p">)</span></div>

<div class="viewcode-block" id="BeamSearchHelper.BeamSearchDecode"><a class="viewcode-back" href="../../../lingvo.core.beam_search_helper.html#lingvo.core.beam_search_helper.BeamSearchHelper.BeamSearchDecode">[docs]</a>  <span class="k">def</span> <span class="nf">BeamSearchDecode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                       <span class="n">theta</span><span class="p">,</span>
                       <span class="n">encoder_outputs</span><span class="p">,</span>
                       <span class="n">num_hyps_per_beam_override</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                       <span class="n">init_beam_search_state</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                       <span class="n">pre_beam_search_step_callback</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                       <span class="n">post_beam_search_step_callback</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                       <span class="n">max_steps</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Performs beam-search based decoding.</span>

<span class="sd">    Args:</span>
<span class="sd">      theta: A NestedMap object containing weights&#39; values of the decoder layer</span>
<span class="sd">        and its children layers.</span>
<span class="sd">      encoder_outputs: A NestedMap containing encoder outputs to be passed to</span>
<span class="sd">        the callbacks. Mostly opaque to BeamSearchHelper, except that it should</span>
<span class="sd">        contain either a &#39;seq_lengths&#39; field of shape [source_batch_size] or</span>
<span class="sd">        a &#39;paddings&#39; field of shape [source_max_lengths, source_batch_size].</span>
<span class="sd">      num_hyps_per_beam_override: If set to a value &lt;= 0, this parameter is</span>
<span class="sd">        ignored. If set to a value &gt; 0, then this value will be used to override</span>
<span class="sd">        `p.num_hyps_per_beam`.</span>
<span class="sd">      init_beam_search_state: The `InitBeamSearchState` callback. Please refer</span>
<span class="sd">        to the class header comments for more details.</span>
<span class="sd">      pre_beam_search_step_callback: The `PreBeamSearchStepCallback` callback.</span>
<span class="sd">        Please refer to the class header comments for more details.</span>
<span class="sd">      post_beam_search_step_callback: The `PostBeamSearchStepCallback` callback.</span>
<span class="sd">        Please refer to the class header comments for more details.</span>
<span class="sd">      max_steps: maximum beam search steps. If None, use</span>
<span class="sd">        self.params.target_seq_len.</span>

<span class="sd">    Returns:</span>
<span class="sd">      A `BeamSearchDecodeOutput`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span>
    <span class="n">num_hyps_per_beam</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">num_hyps_per_beam</span>
    <span class="k">if</span> <span class="n">num_hyps_per_beam_override</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
      <span class="n">num_hyps_per_beam</span> <span class="o">=</span> <span class="n">num_hyps_per_beam_override</span>
    <span class="k">if</span> <span class="n">max_steps</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
      <span class="n">max_steps</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">target_seq_len</span>

    <span class="n">initial_results</span><span class="p">,</span> <span class="n">other_states</span> <span class="o">=</span> <span class="n">init_beam_search_state</span><span class="p">(</span>
        <span class="n">theta</span><span class="p">,</span> <span class="n">encoder_outputs</span><span class="p">,</span> <span class="n">num_hyps_per_beam</span><span class="p">)</span>

    <span class="n">num_hyps</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">initial_results</span><span class="o">.</span><span class="n">log_probs</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">num_beams</span> <span class="o">=</span> <span class="n">num_hyps</span> <span class="o">//</span> <span class="n">num_hyps_per_beam</span>

    <span class="k">if</span> <span class="s1">&#39;step_ids&#39;</span> <span class="ow">in</span> <span class="n">initial_results</span><span class="p">:</span>
      <span class="c1"># [num_hyps, 1]</span>
      <span class="n">step_ids</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">ensure_shape</span><span class="p">(</span><span class="n">initial_results</span><span class="o">.</span><span class="n">step_ids</span><span class="p">,</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">step_ids</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">fill</span><span class="p">([</span><span class="n">num_hyps</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
                         <span class="n">tf</span><span class="o">.</span><span class="n">constant</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">target_sos_id</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">int32</span><span class="p">))</span>

    <span class="n">min_score</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1e36</span>
    <span class="n">best_scores</span> <span class="o">=</span> <span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">[</span><span class="n">num_beams</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">p</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span> <span class="o">+</span> <span class="n">min_score</span><span class="p">)</span>
    <span class="n">cumulative_scores</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">[</span><span class="n">num_hyps</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">p</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">in_scores</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">max_steps</span><span class="p">,</span> <span class="n">num_hyps</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">p</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">in_hyps</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">max_steps</span><span class="p">,</span> <span class="n">num_hyps</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
    <span class="n">in_prev_hyps</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">max_steps</span><span class="p">,</span> <span class="n">num_hyps</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
    <span class="n">in_done_hyps</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">max_steps</span><span class="p">,</span> <span class="n">num_hyps</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">string</span><span class="p">)</span>
    <span class="n">bs_atten_probs</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
        <span class="p">[</span><span class="n">max_steps</span><span class="p">,</span> <span class="n">num_hyps</span><span class="p">,</span>
         <span class="n">tf</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">initial_results</span><span class="o">.</span><span class="n">atten_probs</span><span class="p">)[</span><span class="mi">1</span><span class="p">]],</span>
        <span class="n">dtype</span><span class="o">=</span><span class="n">p</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">beam_done</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">num_beams</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span>
    <span class="n">cur_step</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">constant</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
    <span class="n">all_done</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">constant</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span>
    <span class="n">core_bs_states</span> <span class="o">=</span> <span class="p">(</span><span class="n">best_scores</span><span class="p">,</span> <span class="n">cumulative_scores</span><span class="p">,</span> <span class="n">in_scores</span><span class="p">,</span> <span class="n">in_hyps</span><span class="p">,</span>
                      <span class="n">in_prev_hyps</span><span class="p">,</span> <span class="n">in_done_hyps</span><span class="p">,</span> <span class="n">bs_atten_probs</span><span class="p">,</span> <span class="n">beam_done</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">LoopContinue</span><span class="p">(</span><span class="n">cur_step</span><span class="p">,</span> <span class="n">all_done</span><span class="p">,</span> <span class="n">unused_step_ids</span><span class="p">,</span> <span class="n">unused_core_bs_states</span><span class="p">,</span>
                     <span class="n">unused_other_states_list</span><span class="p">):</span>
      <span class="k">return</span> <span class="n">tf</span><span class="o">.</span><span class="n">math</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">cur_step</span> <span class="o">&lt;</span> <span class="n">max_steps</span><span class="p">,</span>
                                 <span class="n">tf</span><span class="o">.</span><span class="n">math</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">all_done</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">LoopBody</span><span class="p">(</span><span class="n">cur_step</span><span class="p">,</span> <span class="n">unused_all_done</span><span class="p">,</span> <span class="n">step_ids</span><span class="p">,</span> <span class="n">core_bs_states</span><span class="p">,</span>
                 <span class="n">other_states_list</span><span class="p">):</span>
      <span class="p">(</span><span class="n">cur_step</span><span class="p">,</span> <span class="n">all_done</span><span class="p">,</span> <span class="n">new_step_ids</span><span class="p">,</span> <span class="n">new_bs_states</span><span class="p">,</span>
       <span class="n">new_other_states</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_BeamSearchStep</span><span class="p">(</span>
           <span class="n">theta</span><span class="p">,</span> <span class="n">encoder_outputs</span><span class="p">,</span> <span class="n">cur_step</span><span class="p">,</span> <span class="n">step_ids</span><span class="p">,</span> <span class="n">core_bs_states</span><span class="p">,</span>
           <span class="n">other_states</span><span class="o">.</span><span class="n">Pack</span><span class="p">(</span><span class="n">other_states_list</span><span class="p">),</span> <span class="n">num_hyps_per_beam</span><span class="p">,</span>
           <span class="n">pre_beam_search_step_callback</span><span class="p">,</span> <span class="n">post_beam_search_step_callback</span><span class="p">)</span>
      <span class="k">return</span> <span class="p">(</span><span class="n">cur_step</span><span class="p">,</span> <span class="n">all_done</span><span class="p">,</span> <span class="n">new_step_ids</span><span class="p">,</span> <span class="n">new_bs_states</span><span class="p">,</span>
              <span class="n">new_other_states</span><span class="o">.</span><span class="n">Flatten</span><span class="p">())</span>

    <span class="n">flat_other_states</span> <span class="o">=</span> <span class="n">other_states</span><span class="o">.</span><span class="n">Flatten</span><span class="p">()</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">final_bs_states</span><span class="p">,</span> <span class="n">flat_final_other_states</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">while_loop</span><span class="p">(</span>
        <span class="n">LoopContinue</span><span class="p">,</span>
        <span class="n">LoopBody</span><span class="p">,</span>
        <span class="n">loop_vars</span><span class="o">=</span><span class="p">(</span><span class="n">cur_step</span><span class="p">,</span> <span class="n">all_done</span><span class="p">,</span> <span class="n">step_ids</span><span class="p">,</span> <span class="n">core_bs_states</span><span class="p">,</span>
                   <span class="n">flat_other_states</span><span class="p">),</span>
        <span class="n">parallel_iterations</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
        <span class="n">back_prop</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">swap_memory</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">shape_invariants</span><span class="o">=</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">TensorShape</span><span class="p">(</span><span class="n">cur_step</span><span class="o">.</span><span class="n">get_shape</span><span class="p">()),</span>
                          <span class="n">tf</span><span class="o">.</span><span class="n">TensorShape</span><span class="p">(</span><span class="n">all_done</span><span class="o">.</span><span class="n">get_shape</span><span class="p">()),</span>
                          <span class="n">tf</span><span class="o">.</span><span class="n">TensorShape</span><span class="p">(</span><span class="n">step_ids</span><span class="o">.</span><span class="n">get_shape</span><span class="p">()),</span>
                          <span class="n">_GetShapes</span><span class="p">(</span><span class="n">core_bs_states</span><span class="p">),</span>
                          <span class="n">_GetShapes</span><span class="p">(</span><span class="n">flat_other_states</span><span class="p">,</span> <span class="n">none_shapes</span><span class="o">=</span><span class="kc">True</span><span class="p">)))</span>
    <span class="c1"># [target_seq_len, num_beams * num_hyps_per_beam].</span>
    <span class="n">final_done_hyps</span> <span class="o">=</span> <span class="n">final_bs_states</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span>
    <span class="n">final_other_states</span> <span class="o">=</span> <span class="n">other_states</span><span class="o">.</span><span class="n">Pack</span><span class="p">(</span><span class="n">flat_final_other_states</span><span class="p">)</span>

    <span class="c1"># Assume that `paddings` has shape [source_max_lengths, source_batch_size]</span>
    <span class="c1"># by default, and compute `encoded_seq_lengths` accordingly. This can be</span>
    <span class="c1"># overridden by directly passing `seq_lengths` in the `encoder_outputs`</span>
    <span class="c1"># NestedMap.</span>
    <span class="n">encoded_seq_lengths</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">encoder_outputs</span><span class="p">,</span> <span class="s1">&#39;seq_lengths&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">encoded_seq_lengths</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
      <span class="n">source_paddings</span> <span class="o">=</span> <span class="n">encoder_outputs</span><span class="o">.</span><span class="n">padding</span>
      <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">source_paddings</span><span class="p">,</span> <span class="n">py_utils</span><span class="o">.</span><span class="n">NestedMap</span><span class="p">):</span>
        <span class="n">encoded_seq_lengths</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span>
            <span class="n">tf</span><span class="o">.</span><span class="n">round</span><span class="p">(</span>
                <span class="n">tf</span><span class="o">.</span><span class="n">reduce_sum</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">tf</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">source_paddings</span><span class="o">.</span><span class="n">Flatten</span><span class="p">()[</span><span class="mi">0</span><span class="p">]),</span>
                              <span class="mi">1</span><span class="p">)),</span> <span class="n">tf</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="n">encoded_seq_lengths</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span>
            <span class="n">tf</span><span class="o">.</span><span class="n">round</span><span class="p">(</span>
                <span class="n">tf</span><span class="o">.</span><span class="n">reduce_sum</span><span class="p">(</span>
                    <span class="mf">1.0</span> <span class="o">-</span> <span class="n">tf</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">source_paddings</span><span class="p">),</span> <span class="n">tf</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span>
                    <span class="mi">1</span><span class="p">)),</span> <span class="n">tf</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>

    <span class="c1"># [num_beams, num_hyps_per_beam].</span>
    <span class="n">topk_hyps</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">top_k_terminated_hyps</span><span class="p">(</span>
        <span class="n">final_done_hyps</span><span class="p">,</span>
        <span class="n">encoded_seq_lengths</span><span class="p">,</span>
        <span class="n">k</span><span class="o">=</span><span class="n">num_hyps_per_beam</span><span class="p">,</span>
        <span class="n">num_hyps_per_beam</span><span class="o">=</span><span class="n">num_hyps_per_beam</span><span class="p">,</span>
        <span class="n">length_normalization</span><span class="o">=</span><span class="n">p</span><span class="o">.</span><span class="n">length_normalization</span><span class="p">,</span>
        <span class="n">coverage_penalty</span><span class="o">=</span><span class="n">p</span><span class="o">.</span><span class="n">coverage_penalty</span><span class="p">,</span>
        <span class="n">target_seq_length_ratio</span><span class="o">=</span><span class="n">p</span><span class="o">.</span><span class="n">target_seq_length_ratio</span><span class="p">)</span>
    <span class="c1"># [num_beams * num_hyps_per_beam, ...].</span>
    <span class="n">max_seq_length</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">max_steps</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">)</span> <span class="k">else</span> <span class="n">max_steps</span>
    <span class="n">topk_ids</span><span class="p">,</span> <span class="n">topk_lens</span><span class="p">,</span> <span class="n">topk_scores</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">unpack_hyp</span><span class="p">(</span>
        <span class="n">tf</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">topk_hyps</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="n">max_seq_length</span><span class="o">=</span><span class="n">max_seq_length</span><span class="p">)</span>
    <span class="c1"># [num_beams, num_hyps_per_beam].</span>
    <span class="n">topk_scores</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">topk_scores</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">topk_hyps</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">BeamSearchDecodeOutput</span><span class="p">(</span><span class="n">topk_hyps</span><span class="p">,</span> <span class="n">topk_ids</span><span class="p">,</span> <span class="n">topk_lens</span><span class="p">,</span> <span class="n">topk_scores</span><span class="p">,</span>
                                  <span class="kc">None</span><span class="p">,</span> <span class="n">final_other_states</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="_GetShapes"><a class="viewcode-back" href="../../../lingvo.core.beam_search_helper.html#lingvo.core.beam_search_helper._GetShapes">[docs]</a><span class="k">def</span> <span class="nf">_GetShapes</span><span class="p">(</span><span class="n">tensors</span><span class="p">,</span> <span class="n">none_shapes</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Util for getting nested structure of shapes from structure of tensors.</span>

<span class="sd">  Args:</span>
<span class="sd">    tensors: Structure of Tensors to get shapes for.</span>
<span class="sd">    none_shapes: Returns None shapes if true.</span>

<span class="sd">  Returns:</span>
<span class="sd">    The same structure as tensors but of corresponding `TensorShape` objects.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="n">shapes</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tf</span><span class="o">.</span><span class="n">nest</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">tensors</span><span class="p">):</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">get_shape</span><span class="p">()</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">)</span> <span class="k">else</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">none_shapes</span><span class="p">:</span>
      <span class="k">if</span> <span class="n">shape</span><span class="p">:</span>
        <span class="n">shapes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">TensorShape</span><span class="p">([</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)))</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="n">shapes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">TensorShape</span><span class="p">(</span><span class="kc">None</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">shapes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">TensorShape</span><span class="p">(</span><span class="n">shape</span><span class="p">))</span>

  <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="n">tensors</span><span class="p">)(</span><span class="n">tf</span><span class="o">.</span><span class="n">nest</span><span class="o">.</span><span class="n">pack_sequence_as</span><span class="p">(</span><span class="n">tensors</span><span class="p">,</span> <span class="n">shapes</span><span class="p">))</span></div>


<div class="viewcode-block" id="MergeBeamSearchOutputs"><a class="viewcode-back" href="../../../lingvo.core.beam_search_helper.html#lingvo.core.beam_search_helper.MergeBeamSearchOutputs">[docs]</a><span class="k">def</span> <span class="nf">MergeBeamSearchOutputs</span><span class="p">(</span><span class="n">max_hyps_per_beam</span><span class="p">,</span> <span class="n">beam_search_outputs</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Merges beam search hyps from multiple decoders.</span>

<span class="sd">  Args:</span>
<span class="sd">    max_hyps_per_beam: the number of top hyps in the merged results. Must be</span>
<span class="sd">      less than or equal to total number of input hyps.</span>
<span class="sd">    beam_search_outputs: a list of BeamSearchDecodeOutput objects. Must share</span>
<span class="sd">      the same source_batch and max sequence length.</span>

<span class="sd">  Returns:</span>
<span class="sd">    A BeamSearchDecodeOutput object containing max_hyps_per_beam hypotheses per</span>
<span class="sd">    beam.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="n">source_batch</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">beam_search_outputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">topk_hyps</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
  <span class="n">value_dict</span> <span class="o">=</span> <span class="p">{}</span>
  <span class="k">for</span> <span class="n">output</span> <span class="ow">in</span> <span class="n">beam_search_outputs</span><span class="p">:</span>
    <span class="n">hyps_per_beam</span> <span class="o">=</span> <span class="n">py_utils</span><span class="o">.</span><span class="n">with_dependencies</span><span class="p">([</span>
        <span class="n">py_utils</span><span class="o">.</span><span class="n">assert_equal</span><span class="p">(</span><span class="n">source_batch</span><span class="p">,</span>
                              <span class="n">tf</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">output</span><span class="o">.</span><span class="n">topk_hyps</span><span class="p">)[</span><span class="mi">0</span><span class="p">]),</span>
    <span class="p">],</span>
                                               <span class="n">tf</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">output</span><span class="o">.</span><span class="n">topk_hyps</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">output</span><span class="o">.</span><span class="n">_asdict</span><span class="p">()</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
      <span class="k">if</span> <span class="n">v</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">continue</span>
      <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="s1">&#39;done_hyps&#39;</span><span class="p">:</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
      <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">value_dict</span><span class="p">:</span>
        <span class="n">value_dict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
      <span class="n">value_dict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="p">[</span><span class="n">source_batch</span><span class="p">,</span> <span class="n">hyps_per_beam</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]))</span>

  <span class="c1"># Concatenate the tensors along the &#39;num_hyps_per_beam&#39; dimension.</span>
  <span class="n">concatenated</span> <span class="o">=</span> <span class="p">{}</span>
  <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">values</span> <span class="ow">in</span> <span class="n">value_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">beam_search_outputs</span><span class="p">):</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Incomplete values for </span><span class="si">%s</span><span class="s1">: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span>
                       <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">beam_search_outputs</span><span class="p">))</span>
    <span class="n">concatenated</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

  <span class="n">scores</span> <span class="o">=</span> <span class="n">concatenated</span><span class="p">[</span><span class="s1">&#39;topk_scores&#39;</span><span class="p">]</span>
  <span class="n">scores</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
      <span class="n">tf</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">concatenated</span><span class="p">[</span><span class="s1">&#39;topk_lens&#39;</span><span class="p">],</span> <span class="mi">0</span><span class="p">),</span> <span class="n">tf</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">scores</span><span class="p">),</span> <span class="o">-</span><span class="mf">1e6</span><span class="p">),</span>
      <span class="n">scores</span><span class="p">)</span>
  <span class="n">scores</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">scores</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

  <span class="c1"># Select top max_hyps_per_beam indices per beam.</span>
  <span class="n">_</span><span class="p">,</span> <span class="n">top_indices</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">top_k</span><span class="p">(</span><span class="n">scores</span><span class="p">,</span> <span class="n">max_hyps_per_beam</span><span class="p">)</span>
  <span class="n">batch_ids</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span>
      <span class="n">tf</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">range</span><span class="p">(</span><span class="n">source_batch</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">max_hyps_per_beam</span><span class="p">])</span>
  <span class="c1"># [source_batch, max_hyps_per_beam, 2]</span>
  <span class="n">gather_indices</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">batch_ids</span><span class="p">,</span> <span class="n">top_indices</span><span class="p">],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

  <span class="c1"># Gather the merged top hyps according to &#39;gather_indices&#39;.</span>
  <span class="n">top</span> <span class="o">=</span> <span class="n">beam_search_outputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">_asdict</span><span class="p">()</span>
  <span class="n">total_hyps</span> <span class="o">=</span> <span class="n">source_batch</span> <span class="o">*</span> <span class="n">max_hyps_per_beam</span>
  <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">concatenated</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">gather_nd</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">gather_indices</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="s1">&#39;done_hyps&#39;</span><span class="p">:</span>
      <span class="n">v</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="p">[</span><span class="n">total_hyps</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
    <span class="k">elif</span> <span class="n">k</span> <span class="o">==</span> <span class="s1">&#39;topk_hyps&#39;</span><span class="p">:</span>
      <span class="n">v</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="p">[</span><span class="n">source_batch</span><span class="p">,</span> <span class="n">max_hyps_per_beam</span><span class="p">])</span>
    <span class="k">elif</span> <span class="n">k</span> <span class="o">==</span> <span class="s1">&#39;topk_ids&#39;</span><span class="p">:</span>
      <span class="n">v</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="p">[</span><span class="n">total_hyps</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">elif</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;topk_lens&#39;</span><span class="p">,</span> <span class="s1">&#39;topk_scores&#39;</span><span class="p">,</span> <span class="s1">&#39;topk_decoded&#39;</span><span class="p">):</span>
      <span class="n">v</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="p">[</span><span class="n">total_hyps</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Unexpected field: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">k</span><span class="p">)</span>
    <span class="n">top</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
  <span class="k">return</span> <span class="n">BeamSearchDecodeOutput</span><span class="p">(</span><span class="o">**</span><span class="n">top</span><span class="p">)</span></div>


<div class="viewcode-block" id="GreedySearchHelper"><a class="viewcode-back" href="../../../lingvo.core.beam_search_helper.html#lingvo.core.beam_search_helper.GreedySearchHelper">[docs]</a><span class="k">class</span> <span class="nc">GreedySearchHelper</span><span class="p">(</span><span class="n">base_layer</span><span class="o">.</span><span class="n">BaseLayer</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Helper class for performing greedy decoding.</span>

<span class="sd">  The user of this helper class needs to implement three callbacks just as in a</span>
<span class="sd">  beam search decoder.</span>
<span class="sd">  &quot;&quot;&quot;</span>

<div class="viewcode-block" id="GreedySearchHelper.Params"><a class="viewcode-back" href="../../../lingvo.core.beam_search_helper.html#lingvo.core.beam_search_helper.GreedySearchHelper.Params">[docs]</a>  <span class="nd">@classmethod</span>
  <span class="k">def</span> <span class="nf">Params</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
    <span class="n">p</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">Params</span><span class="p">()</span>
    <span class="n">p</span><span class="o">.</span><span class="n">Define</span><span class="p">(</span><span class="s1">&#39;target_sos_id&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;Id of the start of sentence token.&#39;</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">Define</span><span class="p">(</span><span class="s1">&#39;target_eos_id&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;Id of the end of sentence token.&#39;</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">Define</span><span class="p">(</span>
        <span class="s1">&#39;target_seq_len&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;Maximum allowed target seq length. Note &#39;</span>
        <span class="s1">&#39;that decoding terminates if an end of sentence token &#39;</span>
        <span class="s1">&#39;is not emitted after target_seq_len decode steps.&#39;</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;greedy_search&#39;</span>
    <span class="k">return</span> <span class="n">p</span></div>

<div class="viewcode-block" id="GreedySearchHelper._GreedySearchStep"><a class="viewcode-back" href="../../../lingvo.core.beam_search_helper.html#lingvo.core.beam_search_helper.GreedySearchHelper._GreedySearchStep">[docs]</a>  <span class="k">def</span> <span class="nf">_GreedySearchStep</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">encoder_outputs</span><span class="p">,</span> <span class="n">cur_step</span><span class="p">,</span> <span class="n">step_ids</span><span class="p">,</span>
                        <span class="n">hyp_ids</span><span class="p">,</span> <span class="n">hyp_lens</span><span class="p">,</span> <span class="n">done_hyps</span><span class="p">,</span> <span class="n">other_states</span><span class="p">,</span>
                        <span class="n">pre_beam_search_step_callback</span><span class="p">,</span>
                        <span class="n">post_beam_search_step_callback</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Extend greedy search hyps for one step.</span>

<span class="sd">    Args:</span>
<span class="sd">      theta: A `.NestedMap` object containing weights&#39; values of the decoder</span>
<span class="sd">        layer and its children layers.</span>
<span class="sd">      encoder_outputs: A `.NestedMap` containing encoder outputs to be passed to</span>
<span class="sd">        the callbacks.</span>
<span class="sd">      cur_step: A scalar int tensor, the current time step, 0-based.</span>
<span class="sd">      step_ids: An int tensor of shape [num_hyps, 1]. The input ids to the</span>
<span class="sd">        current search step.</span>
<span class="sd">      hyp_ids: An int tensor of shape [num_hyps, tgt_seq_len].</span>
<span class="sd">      hyp_lens: Valid length of all the hyps. Tokens after eos ids are not</span>
<span class="sd">        counted.</span>
<span class="sd">      done_hyps: Whether or not a hyp has finished.</span>
<span class="sd">      other_states: A `.NestedMap` of other beam search states. This</span>
<span class="sd">        `.NestedMap` is managed and updated by the client. It is expected that</span>
<span class="sd">        each of its member tensors are of rank &gt;= 1. t[i, ...] is the state of</span>
<span class="sd">        the i-th hyp at the beginning of this search step.</span>
<span class="sd">      pre_beam_search_step_callback: The `PreBeamSearchStepCallback` callback.</span>
<span class="sd">        See class header comments for more details.</span>
<span class="sd">      post_beam_search_step_callback: The `PostBeamSearchStepCallback` callback.</span>
<span class="sd">        See class header comments for more details.</span>

<span class="sd">    Returns:</span>
<span class="sd">      A tuple of following elements for the next greedy search step,</span>
<span class="sd">      (next step, new_step_ids, hyp_ids, hyp_lens, done_hyps, other_states)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span>
    <span class="c1"># Increment hyp_lens by 1 if the hyp is not finished yet.</span>
    <span class="n">hyp_lens</span> <span class="o">=</span> <span class="n">hyp_lens</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">tf</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">done_hyps</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">int32</span><span class="p">))</span>

    <span class="n">bs_results</span><span class="p">,</span> <span class="n">new_other_states</span> <span class="o">=</span> <span class="n">pre_beam_search_step_callback</span><span class="p">(</span>
        <span class="n">theta</span><span class="p">,</span> <span class="n">encoder_outputs</span><span class="p">,</span> <span class="n">step_ids</span><span class="p">,</span> <span class="n">other_states</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># num_hyps_per_beam</span>
    <span class="n">new_step_ids</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">math</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">bs_results</span><span class="o">.</span><span class="n">log_probs</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">new_step_ids</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">new_step_ids</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
    <span class="n">new_step_ids</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">new_step_ids</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">step_ids</span><span class="p">))</span>
    <span class="n">final_other_states</span> <span class="o">=</span> <span class="n">post_beam_search_step_callback</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">encoder_outputs</span><span class="p">,</span>
                                                        <span class="n">new_step_ids</span><span class="p">,</span>
                                                        <span class="n">new_other_states</span><span class="p">)</span>

    <span class="c1"># Stash new_step_ids into the right slot.</span>
    <span class="n">new_step_ids_1d</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">new_step_ids</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">hyp_ids</span> <span class="o">=</span> <span class="n">inplace_ops</span><span class="o">.</span><span class="n">alias_inplace_update</span><span class="p">(</span><span class="n">hyp_ids</span><span class="p">,</span> <span class="n">cur_step</span><span class="p">,</span>
                                               <span class="n">new_step_ids_1d</span><span class="p">)</span>
    <span class="c1"># Update done_hyps if the current step_ids is the end of sequence token.</span>
    <span class="n">done_hyps</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">math</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">done_hyps</span><span class="p">,</span>
                                   <span class="n">tf</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">new_step_ids_1d</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">target_eos_id</span><span class="p">))</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">cur_step</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">new_step_ids</span><span class="p">,</span> <span class="n">hyp_ids</span><span class="p">,</span> <span class="n">hyp_lens</span><span class="p">,</span> <span class="n">done_hyps</span><span class="p">,</span>
            <span class="n">final_other_states</span><span class="p">)</span></div>

<div class="viewcode-block" id="GreedySearchHelper.GreedySearchDecode"><a class="viewcode-back" href="../../../lingvo.core.beam_search_helper.html#lingvo.core.beam_search_helper.GreedySearchHelper.GreedySearchDecode">[docs]</a>  <span class="k">def</span> <span class="nf">GreedySearchDecode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                         <span class="n">theta</span><span class="p">,</span>
                         <span class="n">encoder_outputs</span><span class="p">,</span>
                         <span class="n">init_beam_search_state</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                         <span class="n">pre_beam_search_step_callback</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                         <span class="n">post_beam_search_step_callback</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                         <span class="n">max_steps</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Performs greedy-search based decoding.</span>

<span class="sd">    Args:</span>
<span class="sd">      theta: A NestedMap object containing weights&#39; values of the decoder layer</span>
<span class="sd">        and its children layers.</span>
<span class="sd">      encoder_outputs: A NestedMap containing encoder outputs to be passed to</span>
<span class="sd">        the callbacks.</span>
<span class="sd">      init_beam_search_state: The `InitBeamSearchState` callback. Please refer</span>
<span class="sd">        to the class header comments for more details.</span>
<span class="sd">      pre_beam_search_step_callback: The `PreBeamSearchStepCallback` callback.</span>
<span class="sd">        Please refer to the class header comments for more details.</span>
<span class="sd">      post_beam_search_step_callback: The `PostBeamSearchStepCallback` callback.</span>
<span class="sd">        Please refer to the class header comments for more details.</span>
<span class="sd">      max_steps: maximum beam search steps. If None, use</span>
<span class="sd">        self.params.target_seq_len.</span>

<span class="sd">    Returns:</span>
<span class="sd">      A tuple (hyp_ids, hyp_lens, done_hyps). Note that num_hyps is same as</span>
<span class="sd">      src_batch_size.</span>

<span class="sd">        - hyp_ids: [num_hyps, max_step]. Hyps end with &lt;eos&gt; token if the &lt;eos&gt;</span>
<span class="sd">          token is encountered during search.</span>
<span class="sd">        - hyp_lens: [num_hyps].</span>
<span class="sd">        - done_hyps: [num_hyps], whether or not an eos is encountered.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span>
    <span class="k">if</span> <span class="n">max_steps</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
      <span class="n">max_steps</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">target_seq_len</span>

    <span class="n">initial_results</span><span class="p">,</span> <span class="n">other_states</span> <span class="o">=</span> <span class="n">init_beam_search_state</span><span class="p">(</span>
        <span class="n">theta</span><span class="p">,</span>
        <span class="n">encoder_outputs</span><span class="p">,</span>
        <span class="mi">1</span>  <span class="c1"># num_hyps_per_beam</span>
    <span class="p">)</span>

    <span class="n">num_hyps</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">initial_results</span><span class="o">.</span><span class="n">log_probs</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">if</span> <span class="s1">&#39;step_ids&#39;</span> <span class="ow">in</span> <span class="n">initial_results</span><span class="p">:</span>
      <span class="c1"># [num_hyps, 1]</span>
      <span class="n">step_ids</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">ensure_shape</span><span class="p">(</span><span class="n">initial_results</span><span class="o">.</span><span class="n">step_ids</span><span class="p">,</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">step_ids</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">fill</span><span class="p">([</span><span class="n">num_hyps</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
                         <span class="n">tf</span><span class="o">.</span><span class="n">constant</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">target_sos_id</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">int32</span><span class="p">))</span>

    <span class="n">cur_step</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">constant</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
    <span class="n">done_hyps</span> <span class="o">=</span> <span class="n">inplace_ops</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">[</span><span class="n">num_hyps</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">bool</span><span class="p">,</span> <span class="n">init</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                  <span class="n">name</span><span class="o">=</span><span class="s1">&#39;done_hyps&#39;</span><span class="p">)</span>
    <span class="n">hyp_lens</span> <span class="o">=</span> <span class="n">inplace_ops</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">[</span><span class="n">num_hyps</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">init</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                 <span class="n">name</span><span class="o">=</span><span class="s1">&#39;hyp_lens&#39;</span><span class="p">)</span>
    <span class="n">hyp_ids</span> <span class="o">=</span> <span class="n">inplace_ops</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span>
        <span class="n">shape</span><span class="o">=</span><span class="p">[</span><span class="n">max_steps</span><span class="p">,</span> <span class="n">num_hyps</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">init</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">name</span><span class="o">=</span><span class="s1">&#39;hyp_ids&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">LoopContinue</span><span class="p">(</span><span class="n">cur_step</span><span class="p">,</span> <span class="n">unused_step_ids</span><span class="p">,</span> <span class="n">unused_hyp_ids</span><span class="p">,</span> <span class="n">unused_hyp_lens</span><span class="p">,</span>
                     <span class="n">done_hyps</span><span class="p">,</span> <span class="n">unused_other_states_list</span><span class="p">):</span>
      <span class="k">return</span> <span class="n">tf</span><span class="o">.</span><span class="n">math</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">cur_step</span> <span class="o">&lt;</span> <span class="n">max_steps</span><span class="p">,</span>
                                 <span class="n">tf</span><span class="o">.</span><span class="n">math</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">reduce_all</span><span class="p">(</span><span class="n">done_hyps</span><span class="p">)))</span>

    <span class="k">def</span> <span class="nf">LoopBody</span><span class="p">(</span><span class="n">cur_step</span><span class="p">,</span> <span class="n">step_ids</span><span class="p">,</span> <span class="n">hyp_ids</span><span class="p">,</span> <span class="n">hyp_lens</span><span class="p">,</span> <span class="n">done_hyps</span><span class="p">,</span>
                 <span class="n">other_states_list</span><span class="p">):</span>
      <span class="p">(</span><span class="n">cur_step</span><span class="p">,</span> <span class="n">new_step_ids</span><span class="p">,</span> <span class="n">hyp_ids</span><span class="p">,</span> <span class="n">hyp_lens</span><span class="p">,</span> <span class="n">done_hyps</span><span class="p">,</span>
       <span class="n">new_other_states</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_GreedySearchStep</span><span class="p">(</span>
           <span class="n">theta</span><span class="p">,</span> <span class="n">encoder_outputs</span><span class="p">,</span> <span class="n">cur_step</span><span class="p">,</span>
           <span class="n">step_ids</span><span class="p">,</span> <span class="n">hyp_ids</span><span class="p">,</span> <span class="n">hyp_lens</span><span class="p">,</span> <span class="n">done_hyps</span><span class="p">,</span>
           <span class="n">other_states</span><span class="o">.</span><span class="n">Pack</span><span class="p">(</span><span class="n">other_states_list</span><span class="p">),</span> <span class="n">pre_beam_search_step_callback</span><span class="p">,</span>
           <span class="n">post_beam_search_step_callback</span><span class="p">)</span>
      <span class="k">return</span> <span class="p">(</span><span class="n">cur_step</span><span class="p">,</span> <span class="n">new_step_ids</span><span class="p">,</span> <span class="n">hyp_ids</span><span class="p">,</span> <span class="n">hyp_lens</span><span class="p">,</span> <span class="n">done_hyps</span><span class="p">,</span>
              <span class="n">new_other_states</span><span class="o">.</span><span class="n">Flatten</span><span class="p">())</span>

    <span class="n">flat_other_states</span> <span class="o">=</span> <span class="n">other_states</span><span class="o">.</span><span class="n">Flatten</span><span class="p">()</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">final_hyp_ids</span><span class="p">,</span> <span class="n">final_hyp_lens</span><span class="p">,</span> <span class="n">final_done_hyps</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">while_loop</span><span class="p">(</span>
        <span class="n">LoopContinue</span><span class="p">,</span>
        <span class="n">LoopBody</span><span class="p">,</span>
        <span class="n">loop_vars</span><span class="o">=</span><span class="p">(</span><span class="n">cur_step</span><span class="p">,</span> <span class="n">step_ids</span><span class="p">,</span> <span class="n">hyp_ids</span><span class="p">,</span> <span class="n">hyp_lens</span><span class="p">,</span> <span class="n">done_hyps</span><span class="p">,</span>
                   <span class="n">flat_other_states</span><span class="p">),</span>
        <span class="n">parallel_iterations</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
        <span class="n">back_prop</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">swap_memory</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">shape_invariants</span><span class="o">=</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">TensorShape</span><span class="p">(</span><span class="n">cur_step</span><span class="o">.</span><span class="n">get_shape</span><span class="p">()),</span>
                          <span class="n">tf</span><span class="o">.</span><span class="n">TensorShape</span><span class="p">(</span><span class="n">step_ids</span><span class="o">.</span><span class="n">get_shape</span><span class="p">()),</span>
                          <span class="n">tf</span><span class="o">.</span><span class="n">TensorShape</span><span class="p">(</span><span class="n">hyp_ids</span><span class="o">.</span><span class="n">get_shape</span><span class="p">()),</span>
                          <span class="n">tf</span><span class="o">.</span><span class="n">TensorShape</span><span class="p">(</span><span class="n">hyp_lens</span><span class="o">.</span><span class="n">get_shape</span><span class="p">()),</span>
                          <span class="n">tf</span><span class="o">.</span><span class="n">TensorShape</span><span class="p">(</span><span class="n">done_hyps</span><span class="o">.</span><span class="n">get_shape</span><span class="p">()),</span>
                          <span class="n">_GetShapes</span><span class="p">(</span><span class="n">flat_other_states</span><span class="p">,</span> <span class="n">none_shapes</span><span class="o">=</span><span class="kc">True</span><span class="p">)))</span>

    <span class="c1"># transpose hyp_ids so it matches BeamSearchDecode&#39;s output</span>
    <span class="n">final_hyp_ids</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">final_hyp_ids</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">final_hyp_ids</span><span class="p">,</span> <span class="n">final_hyp_lens</span><span class="p">,</span> <span class="n">final_done_hyps</span></div></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2018.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>