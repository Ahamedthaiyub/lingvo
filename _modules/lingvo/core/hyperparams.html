

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>lingvo.core.hyperparams &mdash; Lingvo  documentation</title>
  

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home"> Lingvo
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../lingvo.html">lingvo package</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">Lingvo</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>lingvo.core.hyperparams</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for lingvo.core.hyperparams</h1><div class="highlight"><pre>
<span></span><span class="c1"># Lint as: python3</span>
<span class="c1"># Copyright 2018 The TensorFlow Authors. All Rights Reserved.</span>
<span class="c1">#</span>
<span class="c1"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="c1"># you may not use this file except in compliance with the License.</span>
<span class="c1"># You may obtain a copy of the License at</span>
<span class="c1">#</span>
<span class="c1">#     http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="c1">#</span>
<span class="c1"># Unless required by applicable law or agreed to in writing, software</span>
<span class="c1"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="c1"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="c1"># See the License for the specific language governing permissions and</span>
<span class="c1"># limitations under the License.</span>
<span class="c1"># ==============================================================================</span>
<span class="sd">&quot;&quot;&quot;Defines Params base class, used for defining class/function parameters.&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">ast</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">enum</span>
<span class="kn">import</span> <span class="nn">importlib</span>
<span class="kn">import</span> <span class="nn">inspect</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="p">(</span><span class="n">Any</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Generator</span><span class="p">,</span> <span class="n">Generic</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span>
                    <span class="n">Sequence</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Type</span><span class="p">,</span> <span class="n">TypeVar</span><span class="p">,</span> <span class="n">Union</span><span class="p">)</span>

<span class="kn">import</span> <span class="nn">dataclasses</span>
<span class="kn">import</span> <span class="nn">lingvo.compat</span> <span class="k">as</span> <span class="nn">tf</span>
<span class="kn">from</span> <span class="nn">lingvo.core</span> <span class="kn">import</span> <span class="n">hyperparams_pb2</span>
<span class="kn">from</span> <span class="nn">lingvo.core</span> <span class="kn">import</span> <span class="n">symbolic</span>

<span class="kn">from</span> <span class="nn">google.protobuf</span> <span class="kn">import</span> <span class="n">message</span>
<span class="kn">from</span> <span class="nn">google.protobuf</span> <span class="kn">import</span> <span class="n">text_format</span>


<div class="viewcode-block" id="_QuoteString"><a class="viewcode-back" href="../../../lingvo.core.hyperparams.html#lingvo.core.hyperparams._QuoteString">[docs]</a><span class="k">def</span> <span class="nf">_QuoteString</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Quotes a string with appropriate quotes and escaping.</span>

<span class="sd">  This performs lite escaping by choosing enclosing quotation marks that would</span>
<span class="sd">  escape the least (either single or double quotes) and escaping those quotes</span>
<span class="sd">  and the backslash. Note that this does not escape newlines. If the string</span>
<span class="sd">  contains embedded newlines, they will be output verbatim.</span>

<span class="sd">  Args:</span>
<span class="sd">    s: String to quote.</span>

<span class="sd">  Returns:</span>
<span class="sd">    Quotes string (possibly multiline).</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="n">single_quote_count</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\&#39;</span><span class="s1">&#39;</span><span class="p">)</span>
  <span class="n">double_quote_count</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s1">&#39;&quot;&#39;</span><span class="p">)</span>
  <span class="n">quote_delim</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\&#39;</span><span class="s1">&#39;</span> <span class="k">if</span> <span class="n">single_quote_count</span> <span class="o">&lt;=</span> <span class="n">double_quote_count</span> <span class="k">else</span> <span class="s1">&#39;&quot;&#39;</span>
  <span class="c1"># Apply escaping to the chosen quote character and the backslash.</span>
  <span class="n">encoded</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;([</span><span class="si">%s</span><span class="se">\\</span><span class="s1">])&#39;</span> <span class="o">%</span> <span class="n">quote_delim</span><span class="p">,</span> <span class="sa">r</span><span class="s1">&#39;</span><span class="se">\\</span><span class="s1">\1&#39;</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">quote_delim</span> <span class="o">+</span> <span class="n">encoded</span> <span class="o">+</span> <span class="n">quote_delim</span></div>


<div class="viewcode-block" id="_UnquoteString"><a class="viewcode-back" href="../../../lingvo.core.hyperparams.html#lingvo.core.hyperparams._UnquoteString">[docs]</a><span class="k">def</span> <span class="nf">_UnquoteString</span><span class="p">(</span><span class="n">quoted</span><span class="p">):</span>
  <span class="k">if</span> <span class="n">quoted</span> <span class="ow">and</span> <span class="n">quoted</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;&quot;&#39;</span><span class="p">,</span> <span class="s1">&#39;</span><span class="se">\&#39;</span><span class="s1">&#39;</span><span class="p">]:</span>
    <span class="c1"># Note that only the limited set of escaping produced by _QuoteString is</span>
    <span class="c1"># supported.</span>
    <span class="n">contents</span> <span class="o">=</span> <span class="n">quoted</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="n">quoted</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;&quot;&quot;\\([\\&#39;&quot;])&quot;&quot;&quot;</span><span class="p">,</span> <span class="sa">r</span><span class="s1">&#39;\1&#39;</span><span class="p">,</span> <span class="n">contents</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="c1"># Just return literal text.</span>
    <span class="k">return</span> <span class="n">quoted</span></div>


<div class="viewcode-block" id="_EndsWithTerminalQuote"><a class="viewcode-back" href="../../../lingvo.core.hyperparams.html#lingvo.core.hyperparams._EndsWithTerminalQuote">[docs]</a><span class="k">def</span> <span class="nf">_EndsWithTerminalQuote</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">quote_char</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Returns whether a string ends with a valid terminal quote.&quot;&quot;&quot;</span>
  <span class="n">endm</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;(</span><span class="se">\\</span><span class="s1">*)</span><span class="si">%s</span><span class="s1">$&#39;</span> <span class="o">%</span> <span class="n">quote_char</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="n">endm</span><span class="p">:</span>
    <span class="k">return</span> <span class="kc">False</span>
  <span class="n">backslashes</span> <span class="o">=</span> <span class="n">endm</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">backslashes</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="c1"># Even number of backslashes preceding the quote means the quote is</span>
    <span class="c1"># not escaped.</span>
    <span class="k">return</span> <span class="kc">True</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="c1"># Terminal quote is escaped.</span>
    <span class="k">return</span> <span class="kc">False</span></div>


<div class="viewcode-block" id="_IsNamedTuple"><a class="viewcode-back" href="../../../lingvo.core.hyperparams.html#lingvo.core.hyperparams._IsNamedTuple">[docs]</a><span class="k">def</span> <span class="nf">_IsNamedTuple</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Returns whether an object is an instance of a collections.namedtuple.</span>

<span class="sd">  Examples::</span>

<span class="sd">    _IsNamedTuple((42, &#39;hi&#39;)) ==&gt; False</span>
<span class="sd">    Foo = collections.namedtuple(&#39;Foo&#39;, [&#39;a&#39;, &#39;b&#39;])</span>
<span class="sd">    _IsNamedTuple(Foo(a=42, b=&#39;hi&#39;)) ==&gt; True</span>

<span class="sd">  Args:</span>
<span class="sd">    x: The object to check.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s1">&#39;_fields&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="_SortedDict"><a class="viewcode-back" href="../../../lingvo.core.hyperparams.html#lingvo.core.hyperparams._SortedDict">[docs]</a><span class="k">class</span> <span class="nc">_SortedDict</span><span class="p">(</span><span class="nb">dict</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;A dict with a __repr__ that is always sorted by key.&quot;&quot;&quot;</span>

  <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="s1">&#39;{&#39;</span> <span class="o">+</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
        <span class="s1">&#39;</span><span class="si">%r</span><span class="s1">: </span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">item</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">()))</span> <span class="o">+</span> <span class="s1">&#39;}&#39;</span></div>


<div class="viewcode-block" id="_Param"><a class="viewcode-back" href="../../../lingvo.core.hyperparams.html#lingvo.core.hyperparams._Param">[docs]</a><span class="k">class</span> <span class="nc">_Param</span><span class="p">:</span>
  <span class="sd">&quot;&quot;&quot;Stores data for a single parameter.&quot;&quot;&quot;</span>

  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">default_value</span><span class="p">,</span> <span class="n">description</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="n">name</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_value</span> <span class="o">=</span> <span class="n">default_value</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_description</span> <span class="o">=</span> <span class="n">description</span>

  <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="c1"># pylint: disable=protected-access</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_name</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_value</span>

  <span class="c1"># Deep copy the value only if it is supported.</span>
  <span class="k">def</span> <span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_value</span><span class="p">,</span> <span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">symbolic</span><span class="o">.</span><span class="n">Symbol</span><span class="p">)):</span>
      <span class="c1"># In case self._value is a tensor/symbol, let&#39;s just make a reference.</span>
      <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">value</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_value</span><span class="p">,</span> <span class="n">memo</span><span class="p">)</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">_Param</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_description</span><span class="p">)</span>
    <span class="c1"># Q(yonghui): Is this the right use of memo.</span>
    <span class="n">memo</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)]</span> <span class="o">=</span> <span class="n">p</span>
    <span class="k">return</span> <span class="n">p</span>

<div class="viewcode-block" id="_Param.ToString"><a class="viewcode-back" href="../../../lingvo.core.hyperparams.html#lingvo.core.hyperparams._Param.ToString">[docs]</a>  <span class="k">def</span> <span class="nf">ToString</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nested_depth</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Prints the parameter as a string.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">GetRepr</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
      <span class="sd">&quot;&quot;&quot;Get the representation of `val`.&quot;&quot;&quot;</span>
      <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">Params</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_SortedDict</span><span class="p">({</span><span class="n">k</span><span class="p">:</span> <span class="n">GetRepr</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">val</span><span class="o">.</span><span class="n">IterParams</span><span class="p">()})</span>
      <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_SortedDict</span><span class="p">({</span><span class="n">k</span><span class="p">:</span> <span class="n">GetRepr</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">val</span><span class="o">.</span><span class="n">items</span><span class="p">()})</span>
      <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">))</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">_IsNamedTuple</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
        <span class="c1"># NB: this constructor signature works for tuples, but not namedtuples.</span>
        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="n">val</span><span class="p">)([</span><span class="n">GetRepr</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">val</span><span class="p">])</span>
      <span class="c1"># NOTE(markmurphy): I introduced Repr() because it&#39;s impossible (afaik) to</span>
      <span class="c1"># overwrite the __str__ or __repr__ method of a types.FunctionType object.</span>
      <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="s1">&#39;Repr&#39;</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">val</span><span class="o">.</span><span class="n">Repr</span><span class="p">()</span>
      <span class="k">return</span> <span class="n">val</span>

    <span class="n">nested_indent</span> <span class="o">=</span> <span class="s1">&#39;  &#39;</span> <span class="o">*</span> <span class="n">nested_depth</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_value</span><span class="p">,</span> <span class="n">Params</span><span class="p">):</span>
      <span class="c1"># pylint: disable=protected-access</span>
      <span class="n">value_str</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value</span><span class="o">.</span><span class="n">_ToString</span><span class="p">(</span><span class="n">nested_depth</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_value</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
      <span class="k">return</span> <span class="s1">&#39;</span><span class="si">%s%s</span><span class="s1">: &quot;</span><span class="si">%s</span><span class="s1">&quot;&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">nested_indent</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">value_str</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">GetRepr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_value</span><span class="p">))</span>
    <span class="k">return</span> <span class="s1">&#39;</span><span class="si">%s%s</span><span class="s1">: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">nested_indent</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="p">,</span> <span class="n">value_str</span><span class="p">)</span></div>

<div class="viewcode-block" id="_Param.Set"><a class="viewcode-back" href="../../../lingvo.core.hyperparams.html#lingvo.core.hyperparams._Param.Set">[docs]</a>  <span class="k">def</span> <span class="nf">Set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
    <span class="c1"># Note that we don&#39;t make a copy of Params objects.</span>
    <span class="c1"># TODO(sadovsky): Maybe add safeguard to ensure that Params object is not</span>
    <span class="c1"># owned by other Params objects.</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_value</span> <span class="o">=</span> <span class="n">value</span></div>

<div class="viewcode-block" id="_Param.Get"><a class="viewcode-back" href="../../../lingvo.core.hyperparams.html#lingvo.core.hyperparams._Param.Get">[docs]</a>  <span class="k">def</span> <span class="nf">Get</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value</span></div></div>


<div class="viewcode-block" id="CopyFieldsTo"><a class="viewcode-back" href="../../../lingvo.core.hyperparams.html#lingvo.core.hyperparams.CopyFieldsTo">[docs]</a><span class="k">def</span> <span class="nf">CopyFieldsTo</span><span class="p">(</span><span class="n">from_p</span><span class="p">,</span> <span class="n">to_p</span><span class="p">,</span> <span class="n">skip</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Copy fields from one Params to another, with optional skipped params.</span>

<span class="sd">  Preserves `type(to_p.Instantiate())`. Use `from_p.Copy()` instead if requiring</span>
<span class="sd">  a deep copy of `from_p`, without updating `to_p`.</span>

<span class="sd">  Args:</span>
<span class="sd">    from_p: Source params to copy from.</span>
<span class="sd">    to_p: Destination params to copy to.</span>
<span class="sd">    skip: A string, a list of strings or None. Param names to skip.</span>
<span class="sd">      Automatically skips InstantiableParams&#39; &#39;cls&#39; parameter.</span>

<span class="sd">  Returns:</span>
<span class="sd">    The updated to_p.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="c1"># Normalize.</span>
  <span class="n">skip</span> <span class="o">=</span> <span class="n">skip</span> <span class="k">if</span> <span class="n">skip</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">[]</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">skip</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
    <span class="n">skip</span> <span class="o">=</span> <span class="p">[</span><span class="n">skip</span><span class="p">]</span>

  <span class="n">skip</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;cls&#39;</span><span class="p">)</span>
  <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">from_p</span><span class="o">.</span><span class="n">IterParams</span><span class="p">():</span>
    <span class="k">if</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">skip</span><span class="p">:</span>
      <span class="k">continue</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">Params</span><span class="p">):</span>
      <span class="n">to_p</span><span class="o">.</span><span class="n">Set</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="n">n</span><span class="p">:</span> <span class="n">p</span><span class="o">.</span><span class="n">Copy</span><span class="p">()})</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">to_p</span><span class="o">.</span><span class="n">Set</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="n">n</span><span class="p">:</span> <span class="n">p</span><span class="p">})</span>
  <span class="k">return</span> <span class="n">to_p</span></div>


<span class="n">ParamsT</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;ParamsT&#39;</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="s1">&#39;Params&#39;</span><span class="p">)</span>


<div class="viewcode-block" id="Params"><a class="viewcode-back" href="../../../lingvo.core.hyperparams.html#lingvo.core.hyperparams.Params">[docs]</a><span class="k">class</span> <span class="nc">Params</span><span class="p">:</span>
  <span class="sd">&quot;&quot;&quot;Stores data for a set of parameters.</span>

<span class="sd">  Provides attribute-based API, e.g. &quot;params.foo = 5&quot;.</span>
<span class="sd">  Uses internal {&#39;name&#39;: _Param} dict for storing parameter data.</span>
<span class="sd">  &quot;&quot;&quot;</span>

  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="s1">&#39;_immutable&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_params</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># name =&gt; _Param</span>

  <span class="k">def</span> <span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_immutable</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;This Params instance is immutable.&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;_params&#39;</span> <span class="ow">or</span> <span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;_immutable&#39;</span><span class="p">:</span>
      <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">try</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_params</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">Set</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
      <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_KeyErrorString</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>

  <span class="k">def</span> <span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;_params&#39;</span> <span class="ow">or</span> <span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;_immutable&#39;</span><span class="p">:</span>
      <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
    <span class="k">try</span><span class="p">:</span>
      <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_params</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">Get</span><span class="p">()</span>
    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
      <span class="c1"># cPickle expects __getattr__ to raise AttributeError, not KeyError.</span>
      <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_KeyErrorString</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>

  <span class="k">def</span> <span class="fm">__dir__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
    <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_params</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

  <span class="k">def</span> <span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_params</span>

  <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_params</span><span class="p">)</span>

  <span class="c1"># Note: This gets called by _Param.__eq__() on nested Params objects.</span>
  <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s1">&#39;Params&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Params</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_params</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_params</span>  <span class="c1"># pylint: disable=protected-access</span>

  <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s1">&#39;Params&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">other</span>

  <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ToString</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

<div class="viewcode-block" id="Params._ToString"><a class="viewcode-back" href="../../../lingvo.core.hyperparams.html#lingvo.core.hyperparams.Params._ToString">[docs]</a>  <span class="k">def</span> <span class="nf">_ToString</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nested_depth</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="c1"># Note: We use iteritems() below so as to sort by name.</span>
    <span class="n">sorted_param_strs</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">v</span><span class="o">.</span><span class="n">ToString</span><span class="p">(</span><span class="n">nested_depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_params</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
    <span class="p">]</span>
    <span class="n">nested_indent</span> <span class="o">=</span> <span class="s1">&#39;  &#39;</span> <span class="o">*</span> <span class="n">nested_depth</span>
    <span class="k">return</span> <span class="s1">&#39;{</span><span class="se">\n</span><span class="si">%s</span><span class="se">\n</span><span class="si">%s</span><span class="s1">}&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">sorted_param_strs</span><span class="p">),</span> <span class="n">nested_indent</span><span class="p">)</span></div>

  <span class="c1"># Override __deepcopy__ so that copy.deepcopy(self._params) properly</span>
  <span class="c1"># deep-copies nested Params objects.</span>
  <span class="c1"># TODO(sadovsky): Is it okay not to touch memo?</span>
  <span class="k">def</span> <span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ParamsT</span><span class="p">,</span> <span class="n">unused_memo</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ParamsT</span><span class="p">:</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Copy</span><span class="p">()</span>

<div class="viewcode-block" id="Params._SimilarKeys"><a class="viewcode-back" href="../../../lingvo.core.hyperparams.html#lingvo.core.hyperparams.Params._SimilarKeys">[docs]</a>  <span class="k">def</span> <span class="nf">_SimilarKeys</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;Return a list of params keys that are similar to name.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">_Overlaps</span><span class="p">(</span><span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
      <span class="sd">&quot;&quot;&quot;The fraction of 3-char substrings in &lt;name&gt; that appear in key.&quot;&quot;&quot;</span>
      <span class="n">matches</span> <span class="o">=</span> <span class="mi">0</span>
      <span class="n">trials</span> <span class="o">=</span> <span class="mi">0</span>
      <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="o">-</span> <span class="mi">3</span><span class="p">):</span>
        <span class="n">trials</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">name</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="mi">3</span><span class="p">]</span> <span class="ow">in</span> <span class="n">key</span><span class="p">:</span>
          <span class="n">matches</span> <span class="o">+=</span> <span class="mi">1</span>
      <span class="k">if</span> <span class="n">trials</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">matches</span><span class="p">)</span> <span class="o">/</span> <span class="n">trials</span>
      <span class="k">return</span> <span class="mi">0</span>

    <span class="k">if</span> <span class="s1">&#39;_params&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">:</span>
      <span class="k">return</span> <span class="p">[</span><span class="n">key</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_params</span> <span class="k">if</span> <span class="n">_Overlaps</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">0.5</span><span class="p">]</span>
    <span class="k">return</span> <span class="p">[]</span></div>

<div class="viewcode-block" id="Params._KeyErrorString"><a class="viewcode-back" href="../../../lingvo.core.hyperparams.html#lingvo.core.hyperparams.Params._KeyErrorString">[docs]</a>  <span class="k">def</span> <span class="nf">_KeyErrorString</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="n">similar</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_SimilarKeys</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">similar</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">name</span> <span class="o">+</span> <span class="s1">&#39; (did you mean: [</span><span class="si">%s</span><span class="s1">])&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">similar</span><span class="p">)))</span>
    <span class="k">if</span> <span class="s1">&#39;_params&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">name</span> <span class="o">+</span> <span class="s1">&#39; (keys are </span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_params</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
    <span class="k">return</span> <span class="n">name</span></div>

<div class="viewcode-block" id="Params.Copy"><a class="viewcode-back" href="../../../lingvo.core.hyperparams.html#lingvo.core.hyperparams.Params.Copy">[docs]</a>  <span class="k">def</span> <span class="nf">Copy</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ParamsT</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ParamsT</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Creates a deep copy of self.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_CopyTo</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)())</span></div>

<div class="viewcode-block" id="Params._CopyTo"><a class="viewcode-back" href="../../../lingvo.core.hyperparams.html#lingvo.core.hyperparams.Params._CopyTo">[docs]</a>  <span class="k">def</span> <span class="nf">_CopyTo</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ParamsT</span><span class="p">,</span> <span class="n">res</span><span class="p">:</span> <span class="n">ParamsT</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ParamsT</span><span class="p">:</span>
    <span class="c1"># pylint: disable=protected-access</span>
    <span class="n">res</span><span class="o">.</span><span class="n">_params</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_params</span><span class="p">)</span>
    <span class="n">res</span><span class="o">.</span><span class="n">_immutable</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_immutable</span>
    <span class="c1"># pylint: enable=protected-access</span>
    <span class="k">return</span> <span class="n">res</span></div>

  <span class="c1"># TODO(sadovsky):</span>
  <span class="c1"># - Maybe let users specify whether this parameter is allowed to have</span>
  <span class="c1">#   value=None, and if not, assert on Get(), like required proto field.</span>
  <span class="c1"># - Maybe enforce that value is one of</span>
  <span class="c1">#     {number, string, bool, list, dict, Params}.</span>
<div class="viewcode-block" id="Params.Define"><a class="viewcode-back" href="../../../lingvo.core.hyperparams.html#lingvo.core.hyperparams.Params.Define">[docs]</a>  <span class="k">def</span> <span class="nf">Define</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">default_value</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="n">description</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Defines a parameter.</span>

<span class="sd">    Args:</span>
<span class="sd">      name: The parameter name. Must only contain lowercase letters, numbers,</span>
<span class="sd">        and underscores. Must start with lowercase letter.</span>
<span class="sd">      default_value: Default value for this parameter. May be None.</span>
<span class="sd">      description: String description of this parameter.</span>

<span class="sd">    Raises:</span>
<span class="sd">      AttributeError: If parameter &#39;name&#39; is already defined.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_immutable</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;This Params instance is immutable.&#39;</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span>
        <span class="s1">&#39;^[a-z][a-z0-9_]*$&#39;</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_params</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s1">&#39;Parameter </span><span class="si">%s</span><span class="s1"> is already defined&#39;</span> <span class="o">%</span> <span class="n">name</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_params</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">_Param</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">default_value</span><span class="p">,</span> <span class="n">description</span><span class="p">)</span></div>

<div class="viewcode-block" id="Params.Freeze"><a class="viewcode-back" href="../../../lingvo.core.hyperparams.html#lingvo.core.hyperparams.Params.Freeze">[docs]</a>  <span class="k">def</span> <span class="nf">Freeze</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Marks this Params as immutable.&quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_immutable</span> <span class="o">=</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="Params.IsImmutable"><a class="viewcode-back" href="../../../lingvo.core.hyperparams.html#lingvo.core.hyperparams.Params.IsImmutable">[docs]</a>  <span class="k">def</span> <span class="nf">IsImmutable</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Return whether this Params is immutable.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_immutable</span></div>

<div class="viewcode-block" id="Params._GetNested"><a class="viewcode-back" href="../../../lingvo.core.hyperparams.html#lingvo.core.hyperparams.Params._GetNested">[docs]</a>  <span class="k">def</span> <span class="nf">_GetNested</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">ParamsT</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;Returns nested param by its name.&quot;&quot;&quot;</span>
    <span class="n">parts</span> <span class="o">=</span> <span class="n">name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)</span>
    <span class="n">curr</span> <span class="o">=</span> <span class="bp">self</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">part</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">parts</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
      <span class="c1"># Get the value (nested Params object) associated with name &#39;part&#39;.</span>
      <span class="k">try</span><span class="p">:</span>
        <span class="n">is_list</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;^(.+)\[(.+)\]$&#39;</span><span class="p">,</span> <span class="n">part</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">is_list</span><span class="p">:</span>
          <span class="n">part</span> <span class="o">=</span> <span class="n">is_list</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
          <span class="n">list_index</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">is_list</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
        <span class="c1"># pylint: disable=protected-access</span>
        <span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span><span class="o">.</span><span class="n">_params</span><span class="p">[</span><span class="n">part</span><span class="p">]</span><span class="o">.</span><span class="n">Get</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">is_list</span><span class="p">:</span>
          <span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span><span class="p">[</span><span class="n">list_index</span><span class="p">]</span>
      <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">parts</span><span class="p">[:</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]))</span>
      <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span> <span class="n">Params</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;Cannot introspect </span><span class="si">%s</span><span class="s1"> for </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span>
                                        <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">curr</span><span class="p">),</span> <span class="s1">&#39;.&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">parts</span><span class="p">[:</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])))</span>
    <span class="k">return</span> <span class="n">curr</span><span class="p">,</span> <span class="n">parts</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span></div>

<div class="viewcode-block" id="Params.Set"><a class="viewcode-back" href="../../../lingvo.core.hyperparams.html#lingvo.core.hyperparams.Params.Set">[docs]</a>  <span class="k">def</span> <span class="nf">Set</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ParamsT</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ParamsT</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Sets multiple parameters.</span>

<span class="sd">    Dots in names indicate navigation into nested Params objects. We do not</span>
<span class="sd">    allow navigation into lists or dicts, and may ban these types altogether in</span>
<span class="sd">    favor of string representations.</span>

<span class="sd">    Args:</span>
<span class="sd">      **kwargs: Name-value pairs to set.</span>

<span class="sd">    Returns:</span>
<span class="sd">      self</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_immutable</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;This Params instance is immutable: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
      <span class="c1"># Get nested param.</span>
      <span class="n">param</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_GetNested</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
      <span class="c1"># Update the value associated with key.</span>
      <span class="k">try</span><span class="p">:</span>
        <span class="c1"># pylint: disable=protected-access</span>
        <span class="n">param</span><span class="o">.</span><span class="n">_params</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">Set</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
      <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_KeyErrorString</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>
    <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Params.Get"><a class="viewcode-back" href="../../../lingvo.core.hyperparams.html#lingvo.core.hyperparams.Params.Get">[docs]</a>  <span class="k">def</span> <span class="nf">Get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Get parameter.</span>

<span class="sd">    Dots in names indicate navigation into nested Params objects. We do not</span>
<span class="sd">    allow navigation into lists or dicts, and may ban these types altogether in</span>
<span class="sd">    favor of string representations.</span>

<span class="sd">    Args:</span>
<span class="sd">      name: (str) Name.</span>

<span class="sd">    Returns:</span>
<span class="sd">      value.</span>

<span class="sd">    Raises:</span>
<span class="sd">      AttributeError: if parameter is not found</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">param</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_GetNested</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
    <span class="c1"># Get the value associated with key.</span>
    <span class="k">try</span><span class="p">:</span>
      <span class="c1"># pylint: disable=protected-access</span>
      <span class="k">return</span> <span class="n">param</span><span class="o">.</span><span class="n">_params</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">Get</span><span class="p">()</span>
    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_KeyErrorString</span><span class="p">(</span><span class="n">name</span><span class="p">))</span></div>

<div class="viewcode-block" id="Params.Delete"><a class="viewcode-back" href="../../../lingvo.core.hyperparams.html#lingvo.core.hyperparams.Params.Delete">[docs]</a>  <span class="k">def</span> <span class="nf">Delete</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ParamsT</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ParamsT</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Deletes multiple parameters.</span>

<span class="sd">    Dots in names indicate navigation into nested Params objects. We do not</span>
<span class="sd">    allow navigation into lists or dicts, and may ban these types altogether in</span>
<span class="sd">    favor of string representations.</span>

<span class="sd">    Args:</span>
<span class="sd">      *args: List of names.</span>

<span class="sd">    Returns:</span>
<span class="sd">      self</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_immutable</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;This Params instance is immutable.&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
      <span class="c1"># Get nested param.</span>
      <span class="n">param</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_GetNested</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
      <span class="c1"># Delete the key.</span>
      <span class="k">try</span><span class="p">:</span>
        <span class="c1"># pylint: disable=protected-access</span>
        <span class="k">del</span> <span class="n">param</span><span class="o">.</span><span class="n">_params</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
      <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_KeyErrorString</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>
    <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Params.IterParams"><a class="viewcode-back" href="../../../lingvo.core.hyperparams.html#lingvo.core.hyperparams.Params.IterParams">[docs]</a>  <span class="k">def</span> <span class="nf">IterParams</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Generator</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;Pythonic dict-like iteration.&quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">param</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_params</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
      <span class="k">yield</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">param</span><span class="o">.</span><span class="n">Get</span><span class="p">())</span></div>

<div class="viewcode-block" id="Params.GetKeys"><a class="viewcode-back" href="../../../lingvo.core.hyperparams.html#lingvo.core.hyperparams.Params.GetKeys">[docs]</a>  <span class="k">def</span> <span class="nf">GetKeys</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_params</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span></div>

<div class="viewcode-block" id="Params.ToProto"><a class="viewcode-back" href="../../../lingvo.core.hyperparams.html#lingvo.core.hyperparams.Params.ToProto">[docs]</a>  <span class="k">def</span> <span class="nf">ToProto</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hyperparams_pb2</span><span class="o">.</span><span class="n">Hyperparam</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Writes to a Hyperparams proto.</span>

<span class="sd">    Serializes the Hyperparams into a proto that can be then written to disk or</span>
<span class="sd">    sent over the network. Note that serialization is not guaranteed to be</span>
<span class="sd">    unique or stable (this is a feature of protos themselves, not this code), so</span>
<span class="sd">    using it for fingerprinting for example may not be appropriate. Refer to the</span>
<span class="sd">    ToText() method for a serialization approach that Lingvo controls.</span>

<span class="sd">    Returns:</span>
<span class="sd">      The serialized params as a Hyperparams proto.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">_ToParamValue</span><span class="p">(</span><span class="n">key</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hyperparams_pb2</span><span class="o">.</span><span class="n">HyperparamValue</span><span class="p">:</span>
      <span class="sd">&quot;&quot;&quot;Serializes to HyperparamValue proto.&quot;&quot;&quot;</span>
      <span class="n">param_pb</span> <span class="o">=</span> <span class="n">hyperparams_pb2</span><span class="o">.</span><span class="n">HyperparamValue</span><span class="p">()</span>
      <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">Params</span><span class="p">):</span>
        <span class="n">param_pb</span><span class="o">.</span><span class="n">param_val</span><span class="o">.</span><span class="n">CopyFrom</span><span class="p">(</span><span class="n">_ToParam</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="n">key</span><span class="p">))</span>
      <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="nb">range</span><span class="p">):</span>
        <span class="c1"># The range function is serialized by explicitely calling it.</span>
        <span class="n">param_pb</span><span class="o">.</span><span class="n">list_val</span><span class="o">.</span><span class="n">items</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
            <span class="p">[</span><span class="n">_ToParamValue</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s1">[</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">]&#39;</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">val</span><span class="p">)])</span>
      <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
        <span class="n">param_pb</span><span class="o">.</span><span class="n">tuple_val</span><span class="o">.</span><span class="n">items</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
            <span class="p">[</span><span class="n">_ToParamValue</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s1">[</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">]&#39;</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">val</span><span class="p">)])</span>
      <span class="k">elif</span> <span class="n">dataclasses</span><span class="o">.</span><span class="n">is_dataclass</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="ow">or</span> <span class="n">_IsNamedTuple</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
        <span class="n">val_cls</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
        <span class="n">items</span> <span class="o">=</span> <span class="n">val</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">dataclasses</span><span class="o">.</span><span class="n">is_dataclass</span><span class="p">(</span>
            <span class="n">val</span><span class="p">)</span> <span class="k">else</span> <span class="n">val</span><span class="o">.</span><span class="n">_asdict</span><span class="p">()</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="n">param_pb</span><span class="o">.</span><span class="n">named_tuple_val</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">getmodule</span><span class="p">(</span>
            <span class="n">val_cls</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s1">&#39;/&#39;</span> <span class="o">+</span> <span class="n">val_cls</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="n">param_pb</span><span class="o">.</span><span class="n">named_tuple_val</span><span class="o">.</span><span class="n">items</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
            <span class="p">[</span><span class="n">_ToParamValue</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s1">[</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s1">]&#39;</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">items</span><span class="p">])</span>
      <span class="c1"># Only dicts where all keys are str can be stored as dict_val.</span>
      <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">val</span><span class="p">):</span>
        <span class="n">param_pb</span><span class="o">.</span><span class="n">dict_val</span><span class="o">.</span><span class="n">SetInParent</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">val</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
          <span class="n">param_pb</span><span class="o">.</span><span class="n">dict_val</span><span class="o">.</span><span class="n">items</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">CopyFrom</span><span class="p">(</span><span class="n">_ToParamValue</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s1">[</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s1">]&#39;</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>
      <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="nb">type</span><span class="p">):</span>
        <span class="n">param_pb</span><span class="o">.</span><span class="n">type_val</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">getmodule</span><span class="p">(</span><span class="n">val</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s1">&#39;/&#39;</span> <span class="o">+</span> <span class="n">val</span><span class="o">.</span><span class="vm">__name__</span>
      <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">DType</span><span class="p">):</span>
        <span class="n">param_pb</span><span class="o">.</span><span class="n">dtype_val</span> <span class="o">=</span> <span class="n">val</span><span class="o">.</span><span class="n">name</span>
      <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">param_pb</span><span class="o">.</span><span class="n">string_val</span> <span class="o">=</span> <span class="n">val</span>
      <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="n">param_pb</span><span class="o">.</span><span class="n">bool_val</span> <span class="o">=</span> <span class="n">val</span>
      <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">param_pb</span><span class="o">.</span><span class="n">int_val</span> <span class="o">=</span> <span class="n">val</span>
      <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
        <span class="n">param_pb</span><span class="o">.</span><span class="n">float_val</span> <span class="o">=</span> <span class="n">val</span>
      <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">enum</span><span class="o">.</span><span class="n">Enum</span><span class="p">):</span>
        <span class="n">enum_cls</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
        <span class="n">param_pb</span><span class="o">.</span><span class="n">enum_val</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">getmodule</span><span class="p">(</span>
            <span class="n">enum_cls</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s1">&#39;/&#39;</span> <span class="o">+</span> <span class="n">enum_cls</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="n">param_pb</span><span class="o">.</span><span class="n">enum_val</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">val</span><span class="o">.</span><span class="n">name</span>
      <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">message</span><span class="o">.</span><span class="n">Message</span><span class="p">):</span>
        <span class="n">proto_cls</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
        <span class="n">param_pb</span><span class="o">.</span><span class="n">proto_val</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">getmodule</span><span class="p">(</span>
            <span class="n">proto_cls</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s1">&#39;/&#39;</span> <span class="o">+</span> <span class="n">proto_cls</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="n">param_pb</span><span class="o">.</span><span class="n">proto_val</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span><span class="o">.</span><span class="n">SerializeToString</span><span class="p">()</span>
      <span class="k">elif</span> <span class="n">val</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># We represent a NoneType by the absence of any of the oneof.</span>
        <span class="k">pass</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="n">param_pb</span><span class="o">.</span><span class="n">string_repr_val</span> <span class="o">=</span> <span class="nb">repr</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">param_pb</span>

    <span class="k">def</span> <span class="nf">_ToParam</span><span class="p">(</span><span class="n">val</span><span class="p">:</span> <span class="s1">&#39;Params&#39;</span><span class="p">,</span> <span class="n">prefix</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hyperparams_pb2</span><span class="o">.</span><span class="n">Hyperparam</span><span class="p">:</span>
      <span class="sd">&quot;&quot;&quot;Serializes to Hyperparam proto.&quot;&quot;&quot;</span>
      <span class="n">param_pb</span> <span class="o">=</span> <span class="n">hyperparams_pb2</span><span class="o">.</span><span class="n">Hyperparam</span><span class="p">()</span>
      <span class="k">if</span> <span class="n">prefix</span><span class="p">:</span>
        <span class="n">prefix</span> <span class="o">+=</span> <span class="s1">&#39;.&#39;</span>
      <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">val</span><span class="o">.</span><span class="n">IterParams</span><span class="p">():</span>
        <span class="n">param_pb</span><span class="o">.</span><span class="n">items</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">CopyFrom</span><span class="p">(</span><span class="n">_ToParamValue</span><span class="p">(</span><span class="n">prefix</span> <span class="o">+</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>
      <span class="k">return</span> <span class="n">param_pb</span>

    <span class="k">return</span> <span class="n">_ToParam</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>

  <span class="c1"># TODO(tonybruguier): Move to module-level function (cls is never used).</span>
<div class="viewcode-block" id="Params.FromProto"><a class="viewcode-back" href="../../../lingvo.core.hyperparams.html#lingvo.core.hyperparams.Params.FromProto">[docs]</a>  <span class="nd">@classmethod</span>
  <span class="k">def</span> <span class="nf">FromProto</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">param_pb</span><span class="p">:</span> <span class="n">hyperparams_pb2</span><span class="o">.</span><span class="n">Hyperparam</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ParamsT</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Reads from a Hyperparams proto.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">_LoadClass</span><span class="p">(</span><span class="n">module_and_class_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Type</span><span class="p">[</span><span class="n">Any</span><span class="p">]:</span>
      <span class="n">tokens</span> <span class="o">=</span> <span class="n">module_and_class_name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)</span>
      <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">,</span> <span class="n">module_and_class_name</span>
      <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">importlib</span><span class="o">.</span><span class="n">import_module</span><span class="p">(</span><span class="n">tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">_FromParamValue</span><span class="p">(</span><span class="n">param_pb</span><span class="p">:</span> <span class="n">hyperparams_pb2</span><span class="o">.</span><span class="n">HyperparamValue</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
      <span class="sd">&quot;&quot;&quot;Deserializes HyperparamValue proto.&quot;&quot;&quot;</span>

      <span class="n">which_oneof</span> <span class="o">=</span> <span class="n">param_pb</span><span class="o">.</span><span class="n">WhichOneof</span><span class="p">(</span><span class="s1">&#39;kind&#39;</span><span class="p">)</span>
      <span class="k">if</span> <span class="ow">not</span> <span class="n">which_oneof</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>
      <span class="k">elif</span> <span class="n">which_oneof</span> <span class="o">==</span> <span class="s1">&#39;param_val&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_FromParam</span><span class="p">(</span><span class="n">param_pb</span><span class="o">.</span><span class="n">param_val</span><span class="p">)</span>
      <span class="k">elif</span> <span class="n">which_oneof</span> <span class="o">==</span> <span class="s1">&#39;list_val&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">_FromParamValue</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">param_pb</span><span class="o">.</span><span class="n">list_val</span><span class="o">.</span><span class="n">items</span><span class="p">]</span>
      <span class="k">elif</span> <span class="n">which_oneof</span> <span class="o">==</span> <span class="s1">&#39;named_tuple_val&#39;</span><span class="p">:</span>
        <span class="n">named_tuple_cls</span> <span class="o">=</span> <span class="n">_LoadClass</span><span class="p">(</span><span class="n">param_pb</span><span class="o">.</span><span class="n">named_tuple_val</span><span class="o">.</span><span class="n">type</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">dataclasses</span><span class="o">.</span><span class="n">is_dataclass</span><span class="p">(</span><span class="n">named_tuple_cls</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">issubclass</span><span class="p">(</span>
            <span class="n">named_tuple_cls</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
          <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">named_tuple_cls</span><span class="p">(</span>
            <span class="o">*</span><span class="p">[</span><span class="n">_FromParamValue</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">param_pb</span><span class="o">.</span><span class="n">named_tuple_val</span><span class="o">.</span><span class="n">items</span><span class="p">])</span>
      <span class="k">elif</span> <span class="n">which_oneof</span> <span class="o">==</span> <span class="s1">&#39;tuple_val&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">_FromParamValue</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">param_pb</span><span class="o">.</span><span class="n">tuple_val</span><span class="o">.</span><span class="n">items</span><span class="p">])</span>
      <span class="k">elif</span> <span class="n">which_oneof</span> <span class="o">==</span> <span class="s1">&#39;dict_val&#39;</span><span class="p">:</span>
        <span class="n">dict_val</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">param_pb</span><span class="o">.</span><span class="n">dict_val</span><span class="o">.</span><span class="n">items</span><span class="p">:</span>
          <span class="n">dict_val</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">_FromParamValue</span><span class="p">(</span><span class="n">param_pb</span><span class="o">.</span><span class="n">dict_val</span><span class="o">.</span><span class="n">items</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">dict_val</span>
      <span class="k">elif</span> <span class="n">which_oneof</span> <span class="o">==</span> <span class="s1">&#39;type_val&#39;</span><span class="p">:</span>
        <span class="n">tokens</span> <span class="o">=</span> <span class="n">param_pb</span><span class="o">.</span><span class="n">type_val</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">importlib</span><span class="o">.</span><span class="n">import_module</span><span class="p">(</span><span class="n">tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
      <span class="k">elif</span> <span class="n">which_oneof</span> <span class="o">==</span> <span class="s1">&#39;dtype_val&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">tf</span><span class="o">.</span><span class="n">as_dtype</span><span class="p">(</span><span class="n">param_pb</span><span class="o">.</span><span class="n">dtype_val</span><span class="p">)</span>
      <span class="k">elif</span> <span class="n">which_oneof</span> <span class="o">==</span> <span class="s1">&#39;enum_val&#39;</span><span class="p">:</span>
        <span class="n">enum_cls</span> <span class="o">=</span> <span class="n">_LoadClass</span><span class="p">(</span><span class="n">param_pb</span><span class="o">.</span><span class="n">enum_val</span><span class="o">.</span><span class="n">type</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">enum_cls</span><span class="p">,</span> <span class="n">enum</span><span class="o">.</span><span class="n">Enum</span><span class="p">):</span>
          <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">enum_cls</span><span class="p">[</span><span class="n">param_pb</span><span class="o">.</span><span class="n">enum_val</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>
      <span class="k">elif</span> <span class="n">which_oneof</span> <span class="o">==</span> <span class="s1">&#39;proto_val&#39;</span><span class="p">:</span>
        <span class="n">proto_cls</span> <span class="o">=</span> <span class="n">_LoadClass</span><span class="p">(</span><span class="n">param_pb</span><span class="o">.</span><span class="n">proto_val</span><span class="o">.</span><span class="n">type</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">proto_cls</span><span class="p">,</span> <span class="n">message</span><span class="o">.</span><span class="n">Message</span><span class="p">):</span>
          <span class="k">return</span> <span class="kc">None</span>
        <span class="n">proto_msg</span> <span class="o">=</span> <span class="n">proto_cls</span><span class="p">()</span>
        <span class="n">proto_msg</span><span class="o">.</span><span class="n">ParseFromString</span><span class="p">(</span><span class="n">param_pb</span><span class="o">.</span><span class="n">proto_val</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">proto_msg</span>
      <span class="k">elif</span> <span class="n">which_oneof</span> <span class="o">==</span> <span class="s1">&#39;string_repr_val&#39;</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Cannot deserialize string_repr_val instance: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span>
                        <span class="n">param_pb</span><span class="o">.</span><span class="n">string_repr_val</span><span class="p">)</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">param_pb</span><span class="p">,</span> <span class="n">which_oneof</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_FromParam</span><span class="p">(</span><span class="n">param_pb</span><span class="p">:</span> <span class="n">hyperparams_pb2</span><span class="o">.</span><span class="n">Hyperparam</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ParamsT</span><span class="p">:</span>
      <span class="sd">&quot;&quot;&quot;Deserializes Hyperparam proto.&quot;&quot;&quot;</span>

      <span class="k">if</span> <span class="s1">&#39;cls&#39;</span> <span class="ow">in</span> <span class="n">param_pb</span><span class="o">.</span><span class="n">items</span><span class="p">:</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">InstantiableParams</span><span class="p">(</span><span class="n">_FromParamValue</span><span class="p">(</span><span class="n">param_pb</span><span class="o">.</span><span class="n">items</span><span class="p">[</span><span class="s1">&#39;cls&#39;</span><span class="p">]))</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">Params</span><span class="p">()</span>
      <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">param_pb</span><span class="o">.</span><span class="n">items</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">k</span> <span class="o">!=</span> <span class="s1">&#39;cls&#39;</span><span class="p">:</span>
          <span class="n">params</span><span class="o">.</span><span class="n">Define</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">_FromParamValue</span><span class="p">(</span><span class="n">param_pb</span><span class="o">.</span><span class="n">items</span><span class="p">[</span><span class="n">k</span><span class="p">]),</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">params</span>

    <span class="k">return</span> <span class="n">_FromParam</span><span class="p">(</span><span class="n">param_pb</span><span class="p">)</span></div>

<div class="viewcode-block" id="Params.ToText"><a class="viewcode-back" href="../../../lingvo.core.hyperparams.html#lingvo.core.hyperparams.Params.ToText">[docs]</a>  <span class="k">def</span> <span class="nf">ToText</span><span class="p">(</span>
      <span class="bp">self</span><span class="p">,</span>
      <span class="n">include_types</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]:</span>
    <span class="sd">&quot;&quot;&quot;Encodes params into a simple text format.</span>

<span class="sd">    Each param is represented as a single line in the output.  The param</span>
<span class="sd">    name and value is separated by a &quot;:&quot;.  The nest param name is</span>
<span class="sd">    separated by &quot;.&quot;.  For values of non-trivial types (types other than</span>
<span class="sd">    int, float, bool, str, and a few, etc.), we just print out the name</span>
<span class="sd">    of its type.</span>

<span class="sd">    Note that strings are enclosed in appropriate single or double quotes</span>
<span class="sd">    (whichever would involve the least escaping) and will have some characters</span>
<span class="sd">    backslash escaped. String properties can span multiple lines.</span>

<span class="sd">    Args:</span>
<span class="sd">      include_types: Should we return types of the values. If True, the types</span>
<span class="sd">        dict will be returned as a second val in a return tuple</span>

<span class="sd">    Returns:</span>
<span class="sd">      The encoded text or (encoded text, types dict) if include_types is True.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">kv</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">types</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">def</span> <span class="nf">GetRepr</span><span class="p">(</span><span class="n">val</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
      <span class="sd">&quot;&quot;&quot;Get the representation of `val`.&quot;&quot;&quot;</span>
      <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">Params</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_SortedDict</span><span class="p">({</span><span class="n">k</span><span class="p">:</span> <span class="n">GetRepr</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">val</span><span class="o">.</span><span class="n">IterParams</span><span class="p">()})</span>
      <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_SortedDict</span><span class="p">({</span><span class="n">k</span><span class="p">:</span> <span class="n">GetRepr</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">val</span><span class="o">.</span><span class="n">items</span><span class="p">()})</span>
      <span class="k">if</span> <span class="n">dataclasses</span><span class="o">.</span><span class="n">is_dataclass</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_SortedDict</span><span class="p">({</span><span class="n">k</span><span class="p">:</span> <span class="n">GetRepr</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">val</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">items</span><span class="p">()})</span>
      <span class="k">if</span> <span class="n">_IsNamedTuple</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_SortedDict</span><span class="p">({</span><span class="n">k</span><span class="p">:</span> <span class="n">GetRepr</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">val</span><span class="o">.</span><span class="n">_asdict</span><span class="p">()</span><span class="o">.</span><span class="n">items</span><span class="p">()})</span>
      <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="n">val</span><span class="p">)([</span><span class="n">GetRepr</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">val</span><span class="p">])</span>
      <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">bool</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="n">enum</span><span class="o">.</span><span class="n">Enum</span><span class="p">)):</span>
        <span class="k">return</span> <span class="n">val</span>
      <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">DType</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">val</span><span class="o">.</span><span class="n">name</span>
      <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">message</span><span class="o">.</span><span class="n">Message</span><span class="p">):</span>
        <span class="n">proto_str</span> <span class="o">=</span> <span class="n">text_format</span><span class="o">.</span><span class="n">MessageToString</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">as_one_line</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="s1">&#39;proto/</span><span class="si">%s</span><span class="s1">/</span><span class="si">%s</span><span class="s1">/</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">inspect</span><span class="o">.</span><span class="n">getmodule</span><span class="p">(</span><span class="n">val</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                                   <span class="nb">type</span><span class="p">(</span><span class="n">val</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">proto_str</span><span class="p">)</span>
      <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="nb">type</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;type/&#39;</span> <span class="o">+</span> <span class="n">inspect</span><span class="o">.</span><span class="n">getmodule</span><span class="p">(</span><span class="n">val</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s1">&#39;/&#39;</span> <span class="o">+</span> <span class="n">val</span><span class="o">.</span><span class="vm">__name__</span>
      <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="n">val</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span>

    <span class="k">def</span> <span class="nf">Traverse</span><span class="p">(</span><span class="n">p</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="n">prefix</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">kv</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
      <span class="sd">&quot;&quot;&quot;Traverses &#39;p&#39; and inserts key-value pairs to &#39;kv&#39;.&quot;&quot;&quot;</span>
      <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">Params</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">p</span><span class="o">.</span><span class="n">IterParams</span><span class="p">():</span>
          <span class="n">Traverse</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">prefix</span> <span class="o">+</span> <span class="s1">&#39;.&#39;</span> <span class="o">+</span> <span class="n">key</span><span class="p">,</span> <span class="n">kv</span><span class="p">)</span>
      <span class="k">elif</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">))</span> <span class="ow">and</span>
            <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Params</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">p</span><span class="p">)):</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
          <span class="n">Traverse</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">[</span><span class="si">%d</span><span class="s1">]&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">prefix</span><span class="p">,</span> <span class="n">i</span><span class="p">),</span> <span class="n">kv</span><span class="p">)</span>
      <span class="c1"># TODO(jiahuiyu): Create single-direction DebugString for</span>
      <span class="c1"># List[(str, Params)] pattern and remove redundancies.</span>
      <span class="k">elif</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">))</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span>
          <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span>
          <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">Params</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">p</span><span class="p">)):</span>
        <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">p</span><span class="p">:</span>
          <span class="n">Traverse</span><span class="p">(</span><span class="n">val</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">[</span><span class="si">%s</span><span class="s1">]&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">prefix</span><span class="p">,</span> <span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">kv</span><span class="p">)</span>
      <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">kv</span><span class="p">[</span><span class="n">prefix</span><span class="p">]</span> <span class="o">=</span> <span class="n">_QuoteString</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="n">types</span><span class="p">[</span><span class="n">prefix</span><span class="p">[</span><span class="mi">1</span><span class="p">:]]</span> <span class="o">=</span> <span class="s1">&#39;str&#39;</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="n">kv</span><span class="p">[</span><span class="n">prefix</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">GetRepr</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
        <span class="n">types</span><span class="p">[</span><span class="n">prefix</span><span class="p">[</span><span class="mi">1</span><span class="p">:]]</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span>

    <span class="n">Traverse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">kv</span><span class="p">)</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">kv</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
      <span class="n">ret</span> <span class="o">+=</span> <span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="s1">&#39; : &#39;</span> <span class="o">+</span> <span class="n">v</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="n">types</span><span class="p">)</span> <span class="k">if</span> <span class="n">include_types</span> <span class="k">else</span> <span class="n">ret</span></div>

<div class="viewcode-block" id="Params.FromText"><a class="viewcode-back" href="../../../lingvo.core.hyperparams.html#lingvo.core.hyperparams.Params.FromText">[docs]</a>  <span class="k">def</span> <span class="nf">FromText</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ParamsT</span><span class="p">,</span>
               <span class="n">text</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
               <span class="n">type_overrides</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ParamsT</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Merges params specified in &#39;text&#39; into &#39;params&#39;.</span>

<span class="sd">    &#39;text&#39; follows the simple text format as produced by ToText.</span>
<span class="sd">    For a param specified in both &#39;params&#39; and &#39;text&#39;, overwrites the value in</span>
<span class="sd">    &#39;params&#39; according to &#39;text&#39;. Params specified in &#39;text&#39; but not in &#39;params&#39;</span>
<span class="sd">    are ignored.</span>

<span class="sd">    Args:</span>
<span class="sd">      text: A text representation of params.</span>
<span class="sd">      type_overrides: Overrides for the types of the params.</span>

<span class="sd">    Returns:</span>
<span class="sd">      self</span>

<span class="sd">    Raises:</span>
<span class="sd">      AttributeError: text contains invalid parameter key</span>
<span class="sd">      ValueError: text contains invalid parameter value, or the format is</span>
<span class="sd">                  wrong.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_immutable</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;This Params instance is immutable.&#39;</span><span class="p">)</span>
    <span class="n">kv</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">type_overrides</span> <span class="o">=</span> <span class="n">type_overrides</span> <span class="ow">or</span> <span class="p">{}</span>
    <span class="n">string_continue</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># None or (key, quote, value)</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">text</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">):</span>
      <span class="c1"># Continuing a multi-line string.</span>
      <span class="k">if</span> <span class="n">string_continue</span><span class="p">:</span>
        <span class="n">value_stripped</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">_EndsWithTerminalQuote</span><span class="p">(</span><span class="n">value_stripped</span><span class="p">,</span> <span class="n">string_continue</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
          <span class="c1"># String continues</span>
          <span class="n">string_continue</span> <span class="o">=</span> <span class="p">(</span><span class="n">string_continue</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">string_continue</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                             <span class="n">string_continue</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="n">line</span><span class="p">)</span>
          <span class="k">continue</span>
        <span class="c1"># String terminates.</span>
        <span class="n">kv</span><span class="p">[</span><span class="n">string_continue</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">string_continue</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="n">value_stripped</span>
        <span class="n">string_continue</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">continue</span>

      <span class="c1"># Regular line.</span>
      <span class="n">line</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
      <span class="k">if</span> <span class="ow">not</span> <span class="n">line</span> <span class="ow">or</span> <span class="n">line</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;#&#39;</span><span class="p">:</span>
        <span class="c1"># empty line or comment</span>
        <span class="k">continue</span>
      <span class="n">pair</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;:&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
      <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pair</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">lstrip</span><span class="p">()</span>
        <span class="n">value_stripped</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()</span>
        <span class="c1"># Detect single vs multi-line string start.</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">and</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;&quot;&#39;</span><span class="p">,</span> <span class="s1">&#39;</span><span class="se">\&#39;</span><span class="s1">&#39;</span><span class="p">]:</span>
          <span class="n">quote_char</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
          <span class="k">if</span> <span class="ow">not</span> <span class="n">_EndsWithTerminalQuote</span><span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">quote_char</span><span class="p">):</span>
            <span class="c1"># Multi-line string.</span>
            <span class="n">string_continue</span> <span class="o">=</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">quote_char</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
            <span class="k">continue</span>
        <span class="n">kv</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value_stripped</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Line </span><span class="si">{}</span><span class="s1"> is not in &lt;key&gt;:&lt;value&gt; format&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">line</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_ValueFromText</span><span class="p">(</span><span class="n">key</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">old_val</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
      <span class="sd">&quot;&quot;&quot;Returns the new param value from its text representation.&quot;&quot;&quot;</span>
      <span class="n">val_type</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">old_val</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span>
      <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">old_val</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">val_type</span> <span class="o">=</span> <span class="s1">&#39;str&#39;</span>
      <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">type_overrides</span><span class="p">:</span>
        <span class="n">val_type</span> <span class="o">=</span> <span class="n">type_overrides</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
      <span class="c1"># Converts val (a string) to a best-guessed typed value.</span>
      <span class="k">if</span> <span class="n">val_type</span> <span class="o">==</span> <span class="s1">&#39;bool&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">val</span> <span class="ow">and</span> <span class="p">(</span><span class="n">val</span> <span class="o">!=</span> <span class="s1">&#39;False&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">val</span> <span class="o">!=</span> <span class="s1">&#39;false&#39;</span><span class="p">)</span>
      <span class="k">elif</span> <span class="n">val_type</span> <span class="o">==</span> <span class="s1">&#39;int&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
      <span class="k">elif</span> <span class="n">val_type</span> <span class="o">==</span> <span class="s1">&#39;float&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
      <span class="k">elif</span> <span class="n">val_type</span> <span class="o">==</span> <span class="s1">&#39;DType&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">tf</span><span class="o">.</span><span class="n">as_dtype</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
      <span class="k">elif</span> <span class="n">dataclasses</span><span class="o">.</span><span class="n">is_dataclass</span><span class="p">(</span><span class="n">old_val</span><span class="p">)</span> <span class="ow">or</span> <span class="n">_IsNamedTuple</span><span class="p">(</span><span class="n">old_val</span><span class="p">):</span>
        <span class="c1"># Maps field name to new value (or its string repr, if non-POD).</span>
        <span class="n">name_to_new_value</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">literal_eval</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
        <span class="n">contents</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">items</span> <span class="o">=</span> <span class="n">old_val</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">dataclasses</span><span class="o">.</span><span class="n">is_dataclass</span><span class="p">(</span>
            <span class="n">old_val</span><span class="p">)</span> <span class="k">else</span> <span class="n">old_val</span><span class="o">.</span><span class="n">_asdict</span><span class="p">()</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">old_field_value</span> <span class="ow">in</span> <span class="n">items</span><span class="p">:</span>
          <span class="n">new_field_value</span> <span class="o">=</span> <span class="n">name_to_new_value</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
          <span class="c1"># Recurse to parse any non-POD contents not converted by</span>
          <span class="c1"># literal_eval().</span>
          <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">new_field_value</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">contents</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">_ValueFromText</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">old_field_value</span><span class="p">,</span> <span class="n">new_field_value</span><span class="p">)</span>
          <span class="k">else</span><span class="p">:</span>
            <span class="n">contents</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_field_value</span>
        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="n">old_val</span><span class="p">)(</span><span class="o">**</span><span class="n">contents</span><span class="p">)</span>
      <span class="k">elif</span> <span class="n">val_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;list&#39;</span><span class="p">,</span> <span class="s1">&#39;tuple&#39;</span><span class="p">]:</span>
        <span class="k">return</span> <span class="n">ast</span><span class="o">.</span><span class="n">literal_eval</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
      <span class="k">elif</span> <span class="n">val_type</span> <span class="o">==</span> <span class="s1">&#39;dict&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ast</span><span class="o">.</span><span class="n">literal_eval</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="k">if</span> <span class="n">val</span> <span class="o">!=</span> <span class="s1">&#39;dict&#39;</span> <span class="k">else</span> <span class="p">{}</span>
      <span class="k">elif</span> <span class="n">val_type</span> <span class="o">==</span> <span class="s1">&#39;str&#39;</span><span class="p">:</span>
        <span class="n">val</span> <span class="o">=</span> <span class="n">_UnquoteString</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">val</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;[&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">val</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;]&#39;</span><span class="p">):</span>
          <span class="c1"># We may have stored a list as a string, try converting to a list.</span>
          <span class="c1"># In case of ValueError - use the string as is.</span>
          <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ast</span><span class="o">.</span><span class="n">literal_eval</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
          <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">return</span> <span class="n">val</span>
      <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">old_val</span><span class="p">,</span> <span class="n">enum</span><span class="o">.</span><span class="n">Enum</span><span class="p">):</span>
        <span class="bp">cls</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">name</span> <span class="o">=</span> <span class="n">val</span><span class="o">.</span><span class="n">rpartition</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">val_type</span> <span class="o">!=</span> <span class="bp">cls</span><span class="p">:</span>
          <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Expected enum of class </span><span class="si">%s</span><span class="s1"> but got </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span>
                           <span class="p">(</span><span class="n">val_type</span><span class="p">,</span> <span class="bp">cls</span><span class="p">))</span>
        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="n">old_val</span><span class="p">)[</span><span class="n">name</span><span class="p">]</span>
      <span class="k">elif</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">old_val</span><span class="p">,</span> <span class="nb">type</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">old_val</span><span class="p">,</span> <span class="n">message</span><span class="o">.</span><span class="n">Message</span><span class="p">)</span> <span class="ow">or</span>
            <span class="n">old_val</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">val</span> <span class="o">==</span> <span class="s1">&#39;NoneType&#39;</span><span class="p">:</span>
          <span class="k">return</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="n">old_val</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">val</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;False&#39;</span><span class="p">,</span> <span class="s1">&#39;false&#39;</span><span class="p">):</span>
          <span class="k">return</span> <span class="kc">False</span>
        <span class="k">elif</span> <span class="n">old_val</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">val</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;True&#39;</span><span class="p">,</span> <span class="s1">&#39;true&#39;</span><span class="p">):</span>
          <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="k">try</span><span class="p">:</span>
            <span class="n">val_type</span><span class="p">,</span> <span class="n">pkg</span><span class="p">,</span> <span class="bp">cls</span> <span class="o">=</span> <span class="n">val</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">val_type</span> <span class="o">==</span> <span class="s1">&#39;type&#39;</span><span class="p">:</span>
              <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="n">pkg</span><span class="p">],</span> <span class="bp">cls</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">val_type</span> <span class="o">==</span> <span class="s1">&#39;proto&#39;</span><span class="p">:</span>
              <span class="bp">cls</span><span class="p">,</span> <span class="n">proto_str</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
              <span class="n">proto_cls</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="n">pkg</span><span class="p">],</span> <span class="bp">cls</span><span class="p">)</span>
              <span class="k">if</span> <span class="ow">not</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">proto_cls</span><span class="p">,</span> <span class="n">message</span><span class="o">.</span><span class="n">Message</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> is not a proto class.&#39;</span> <span class="o">%</span> <span class="n">proto_cls</span><span class="p">)</span>
              <span class="k">return</span> <span class="n">text_format</span><span class="o">.</span><span class="n">Parse</span><span class="p">(</span><span class="n">proto_str</span><span class="p">,</span> <span class="n">proto_cls</span><span class="p">())</span>
          <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Error processing </span><span class="si">%r</span><span class="s1"> : </span><span class="si">%r</span><span class="s1"> with </span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">e</span><span class="p">))</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Failed to read a parameter: </span><span class="si">%r</span><span class="s1"> : </span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">))</span>

    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">kv</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
      <span class="n">old_val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Get</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
      <span class="n">new_val</span> <span class="o">=</span> <span class="n">_ValueFromText</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">old_val</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">Set</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">new_val</span><span class="p">})</span>

    <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Params.ToTextWithTypes"><a class="viewcode-back" href="../../../lingvo.core.hyperparams.html#lingvo.core.hyperparams.Params.ToTextWithTypes">[docs]</a>  <span class="k">def</span> <span class="nf">ToTextWithTypes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Same as ToText but encodes both params and their types.&quot;&quot;&quot;</span>
    <span class="n">text</span><span class="p">,</span> <span class="n">types</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ToText</span><span class="p">(</span><span class="n">include_types</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">text</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="se">\n\n</span><span class="s1">&#39;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">types</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
      <span class="n">text</span> <span class="o">+=</span> <span class="n">k</span> <span class="o">+</span> <span class="s1">&#39; : &#39;</span> <span class="o">+</span> <span class="n">v</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="k">return</span> <span class="n">text</span></div>

<div class="viewcode-block" id="Params.FromTextWithTypes"><a class="viewcode-back" href="../../../lingvo.core.hyperparams.html#lingvo.core.hyperparams.Params.FromTextWithTypes">[docs]</a>  <span class="k">def</span> <span class="nf">FromTextWithTypes</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ParamsT</span><span class="p">,</span> <span class="n">text</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ParamsT</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Same as FromText but expects to have types encoded in the text.&quot;&quot;&quot;</span>
    <span class="n">text</span><span class="p">,</span> <span class="n">types_str</span> <span class="o">=</span> <span class="n">text</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n\n</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="n">types</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">types_str</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">):</span>
      <span class="k">if</span> <span class="ow">not</span> <span class="n">row</span><span class="p">:</span>
        <span class="k">continue</span>
      <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">row</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;:&#39;</span><span class="p">)</span>
      <span class="n">types</span><span class="p">[</span><span class="n">k</span><span class="o">.</span><span class="n">strip</span><span class="p">()]</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">FromText</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">type_overrides</span><span class="o">=</span><span class="n">types</span><span class="p">)</span></div>

<div class="viewcode-block" id="Params.TextDiff"><a class="viewcode-back" href="../../../lingvo.core.hyperparams.html#lingvo.core.hyperparams.Params.TextDiff">[docs]</a>  <span class="k">def</span> <span class="nf">TextDiff</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ParamsT</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">ParamsT</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Return the differences between this object and another as a string.</span>

<span class="sd">    Args:</span>
<span class="sd">      other: The other Params object.</span>

<span class="sd">    Returns:</span>
<span class="sd">      A string of differences.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">IsStringy</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
      <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">TextDiffHelper</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">spaces</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
      <span class="sd">&quot;&quot;&quot;Return the differences between a and b as a string.&quot;&quot;&quot;</span>
      <span class="k">if</span> <span class="n">a</span> <span class="o">==</span> <span class="n">b</span><span class="p">:</span>
        <span class="k">return</span> <span class="s1">&#39;&#39;</span>

      <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="n">Params</span><span class="p">,</span> <span class="nb">dict</span><span class="p">))</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="p">(</span><span class="n">Params</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)):</span>
        <span class="n">diff</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="n">diff</span> <span class="o">+=</span> <span class="s1">&#39;?&#39;</span> <span class="o">+</span> <span class="n">spaces</span> <span class="o">+</span> <span class="n">key</span> <span class="o">+</span> <span class="s1">&#39;:</span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="n">diff</span> <span class="o">+=</span> <span class="n">TextDiffParamsHelper</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">spaces</span> <span class="o">+</span> <span class="s1">&#39;  &#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">diff</span>

      <span class="n">sequences</span> <span class="o">=</span> <span class="kc">False</span>
      <span class="k">try</span><span class="p">:</span>
        <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
        <span class="n">sequences</span> <span class="o">=</span> <span class="kc">True</span>
      <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
        <span class="k">pass</span>

      <span class="k">if</span> <span class="n">sequences</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">IsStringy</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">IsStringy</span><span class="p">(</span><span class="n">b</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">TextDiffSequenceHelper</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">spaces</span><span class="p">)</span>

      <span class="n">diff</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
      <span class="n">diff</span> <span class="o">+=</span> <span class="s1">&#39;&gt;&#39;</span> <span class="o">+</span> <span class="n">spaces</span> <span class="o">+</span> <span class="n">key</span> <span class="o">+</span> <span class="s1">&#39;: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
      <span class="n">diff</span> <span class="o">+=</span> <span class="s1">&#39;&lt;&#39;</span> <span class="o">+</span> <span class="n">spaces</span> <span class="o">+</span> <span class="n">key</span> <span class="o">+</span> <span class="s1">&#39;: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
      <span class="k">return</span> <span class="n">diff</span>

    <span class="k">def</span> <span class="nf">TextDiffSequenceHelper</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Any</span><span class="p">],</span> <span class="n">b</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Any</span><span class="p">],</span> <span class="n">key</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                               <span class="n">spaces</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
      <span class="sd">&quot;&quot;&quot;Return the differences between a and b as a string.&quot;&quot;&quot;</span>
      <span class="n">diff</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
      <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">max</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)])):</span>
        <span class="n">key_i</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s1">[</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">]&#39;</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">):</span>
          <span class="n">diff</span> <span class="o">+=</span> <span class="n">TextDiffHelper</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">key_i</span><span class="p">,</span> <span class="n">spaces</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
          <span class="n">diff</span> <span class="o">+=</span> <span class="s1">&#39;&gt;&#39;</span> <span class="o">+</span> <span class="n">spaces</span> <span class="o">+</span> <span class="n">key_i</span> <span class="o">+</span> <span class="s1">&#39;: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="n">diff</span> <span class="o">+=</span> <span class="s1">&#39;&lt;&#39;</span> <span class="o">+</span> <span class="n">spaces</span> <span class="o">+</span> <span class="n">key_i</span> <span class="o">+</span> <span class="s1">&#39;: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
      <span class="k">return</span> <span class="n">diff</span>

    <span class="k">def</span> <span class="nf">GetKeys</span><span class="p">(</span><span class="n">params_or_dict</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Params</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
      <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">params_or_dict</span><span class="p">,</span> <span class="n">Params</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">params_or_dict</span><span class="o">.</span><span class="n">GetKeys</span><span class="p">()</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">params_or_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">GetValue</span><span class="p">(</span><span class="n">params_or_dict</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Params</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]],</span>
                 <span class="n">key</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
      <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">params_or_dict</span><span class="p">,</span> <span class="n">Params</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">params_or_dict</span><span class="o">.</span><span class="n">Get</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">params_or_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">TextDiffParamsHelper</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Params</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]],</span>
                             <span class="n">b</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Params</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span>
                                                   <span class="n">Any</span><span class="p">]],</span> <span class="n">spaces</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
      <span class="sd">&quot;&quot;&quot;Return the differences between a and b as a string.&quot;&quot;&quot;</span>
      <span class="n">a_keys</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">GetKeys</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
      <span class="n">b_keys</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">GetKeys</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>
      <span class="n">all_keys</span> <span class="o">=</span> <span class="n">a_keys</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">b_keys</span><span class="p">)</span>
      <span class="n">diff</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
      <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">all_keys</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">a_keys</span> <span class="ow">and</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">b_keys</span><span class="p">:</span>
          <span class="n">diff</span> <span class="o">+=</span> <span class="s1">&#39;&gt;&#39;</span> <span class="o">+</span> <span class="n">spaces</span> <span class="o">+</span> <span class="n">key</span> <span class="o">+</span> <span class="s1">&#39;: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">GetValue</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">key</span><span class="p">))</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="k">elif</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">b_keys</span> <span class="ow">and</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">a_keys</span><span class="p">:</span>
          <span class="n">diff</span> <span class="o">+=</span> <span class="s1">&#39;&lt;&#39;</span> <span class="o">+</span> <span class="n">spaces</span> <span class="o">+</span> <span class="n">key</span> <span class="o">+</span> <span class="s1">&#39;: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">GetValue</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">key</span><span class="p">))</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="k">elif</span> <span class="n">GetValue</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span> <span class="o">!=</span> <span class="n">GetValue</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
          <span class="n">diff</span> <span class="o">+=</span> <span class="n">TextDiffHelper</span><span class="p">(</span>
              <span class="n">GetValue</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">key</span><span class="p">),</span> <span class="n">GetValue</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">key</span><span class="p">),</span> <span class="n">key</span><span class="p">,</span> <span class="n">spaces</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">diff</span>

    <span class="k">return</span> <span class="n">TextDiffParamsHelper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">spaces</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">)</span></div></div>


<span class="n">InstantiableParamsClsT</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;InstantiableParamsClsT&#39;</span><span class="p">)</span>


<div class="viewcode-block" id="InstantiableParams"><a class="viewcode-back" href="../../../lingvo.core.hyperparams.html#lingvo.core.hyperparams.InstantiableParams">[docs]</a><span class="k">class</span> <span class="nc">InstantiableParams</span><span class="p">(</span><span class="n">Params</span><span class="p">,</span> <span class="n">Generic</span><span class="p">[</span><span class="n">InstantiableParamsClsT</span><span class="p">]):</span>
  <span class="sd">&quot;&quot;&quot;Params which can be instantiated.</span>

<span class="sd">  When using InstantiableParams, callers must provide a class which supports</span>
<span class="sd">  initialization using a Params instance.</span>

<span class="sd">  This covers a common use case of Params to hold a configuration for a given</span>
<span class="sd">  class.</span>
<span class="sd">  &quot;&quot;&quot;</span>

  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">cls</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">InstantiableParamsClsT</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">Define</span><span class="p">(</span><span class="s1">&#39;cls&#39;</span><span class="p">,</span> <span class="bp">cls</span><span class="p">,</span> <span class="s1">&#39;Cls that this param object is associated with.&#39;</span><span class="p">)</span>

<div class="viewcode-block" id="InstantiableParams.Instantiate"><a class="viewcode-back" href="../../../lingvo.core.hyperparams.html#lingvo.core.hyperparams.InstantiableParams.Instantiate">[docs]</a>  <span class="k">def</span> <span class="nf">Instantiate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">InstantiableParamsClsT</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Instantiate an instance that this Params is configured for.</span>

<span class="sd">    Example:</span>
<span class="sd">      params = InstantiableParams(cls=MyObject)</span>
<span class="sd">      params.Define(&#39;weight&#39;, 0.2, &#39;Training weight.&#39;)</span>
<span class="sd">      params.weight = 0.9</span>
<span class="sd">      obj = params.Instantiate()</span>

<span class="sd">    It&#39;s common for classes to have a classmethod called Params that returns</span>
<span class="sd">    a pre-made InstantiableParams, like this:</span>

<span class="sd">      params = MyObject.Params()</span>
<span class="sd">      params.weight = 0.9</span>
<span class="sd">      obj = params.Instantiate()</span>

<span class="sd">    By convention, anything that parameterizes the behavior of your class</span>
<span class="sd">    should be stored in this Params object. However, your class may also use</span>
<span class="sd">    shared state objects which aren&#39;t really parameters, like a shared lock.</span>
<span class="sd">    These can be passed as extra arguments to Instantiate.</span>

<span class="sd">    Example:</span>
<span class="sd">      lock = threading.Lock()</span>
<span class="sd">      params = MyObject.Params()</span>
<span class="sd">      obj_a = params.Instantiate(lock=lock)</span>
<span class="sd">      obj_b = params.Instantiate(lock=lock)</span>

<span class="sd">    Args:</span>
<span class="sd">      **args: Additional keyword arguments to pass to the constructor in</span>
<span class="sd">        addition to this Params object.</span>

<span class="sd">    Returns:</span>
<span class="sd">      A constructed object where type(object) == cls.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">cls</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

    <span class="c1"># The class initializer is expected to support initialization using Params.</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cls</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">args</span><span class="p">)</span></div>

<div class="viewcode-block" id="InstantiableParams.Copy"><a class="viewcode-back" href="../../../lingvo.core.hyperparams.html#lingvo.core.hyperparams.InstantiableParams.Copy">[docs]</a>  <span class="k">def</span> <span class="nf">Copy</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ParamsT</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ParamsT</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;See base class.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_CopyTo</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span><span class="bp">self</span><span class="o">.</span><span class="n">cls</span><span class="p">))</span></div></div>
</pre></div>

           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2018.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>