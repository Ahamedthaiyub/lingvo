

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>lingvo.core.quant_utils module &mdash; Lingvo  documentation</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="lingvo.core.recurrent module" href="lingvo.core.recurrent.html" />
    <link rel="prev" title="lingvo.core.quant_test_lib module" href="lingvo.core.quant_test_lib.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> Lingvo
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="lingvo.html">lingvo package</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="lingvo.html#subpackages">Subpackages</a><ul class="current">
<li class="toctree-l3 current"><a class="reference internal" href="lingvo.core.html">lingvo.core package</a><ul class="current">
<li class="toctree-l4"><a class="reference internal" href="lingvo.core.html#subpackages">Subpackages</a></li>
<li class="toctree-l4 current"><a class="reference internal" href="lingvo.core.html#submodules">Submodules</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="lingvo.tasks.html">lingvo.tasks package</a></li>
<li class="toctree-l3"><a class="reference internal" href="lingvo.tools.html">lingvo.tools package</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="lingvo.html#submodules">Submodules</a></li>
</ul>
</li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Lingvo</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="lingvo.html">lingvo package</a> &raquo;</li>
        
          <li><a href="lingvo.core.html">lingvo.core package</a> &raquo;</li>
        
      <li>lingvo.core.quant_utils module</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="_sources/lingvo.core.quant_utils.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="module-lingvo.core.quant_utils">
<span id="lingvo-core-quant-utils-module"></span><h1>lingvo.core.quant_utils module<a class="headerlink" href="#module-lingvo.core.quant_utils" title="Permalink to this headline">¶</a></h1>
<p>Utilities for model quantization.</p>
<dl class="py class">
<dt class="sig sig-object py" id="lingvo.core.quant_utils.InputDistribution">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">lingvo.core.quant_utils.</span></span><span class="sig-name descname"><span class="pre">InputDistribution</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/quant_utils.html#InputDistribution"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lingvo.core.quant_utils.InputDistribution" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3.7/library/enum.html#enum.Enum" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">enum.Enum</span></code></a></p>
<p>Distribution type for the inputs for AqtQdomain.</p>
<p>Symmetric distribution is for signed inputs, here we quantize the inputs using
symmetric range around 0 i.e. in range [-max, max]. Weights are signed.
Positive distribution is for unsigned distribution, here we quantize the
inputs in range [0, max_val]</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="lingvo.core.quant_utils.InputDistribution.SYMMETRIC">
<span class="sig-name descname"><span class="pre">SYMMETRIC</span></span><em class="property"> <span class="pre">=</span> <span class="pre">1</span></em><a class="headerlink" href="#lingvo.core.quant_utils.InputDistribution.SYMMETRIC" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="lingvo.core.quant_utils.InputDistribution.POSITIVE">
<span class="sig-name descname"><span class="pre">POSITIVE</span></span><em class="property"> <span class="pre">=</span> <span class="pre">2</span></em><a class="headerlink" href="#lingvo.core.quant_utils.InputDistribution.POSITIVE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lingvo.core.quant_utils.InputDistribution.Parse">
<em class="property"><span class="pre">classmethod</span> </em><span class="sig-name descname"><span class="pre">Parse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">spec</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><a class="reference external" href="https://docs.python.org/3.7/library/stdtypes.html#str" title="(in Python v3.7)"><span class="pre">str</span></a><span class="p"><span class="pre">,</span> </span><a class="reference internal" href="#lingvo.core.quant_utils.InputDistribution" title="lingvo.core.quant_utils.InputDistribution"><span class="pre">lingvo.core.quant_utils.InputDistribution</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#lingvo.core.quant_utils.InputDistribution" title="lingvo.core.quant_utils.InputDistribution"><span class="pre">lingvo.core.quant_utils.InputDistribution</span></a></span></span><a class="reference internal" href="_modules/lingvo/core/quant_utils.html#InputDistribution.Parse"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lingvo.core.quant_utils.InputDistribution.Parse" title="Permalink to this definition">¶</a></dt>
<dd><p>Parses or returns an InputDistribution.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>spec</strong> – An InputDistribution instance or the case-insensitive name of one of
the enum values.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>An InputDistribution instance.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="lingvo.core.quant_utils.QuantizableLayer">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">lingvo.core.quant_utils.</span></span><span class="sig-name descname"><span class="pre">QuantizableLayer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/quant_utils.html#QuantizableLayer"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lingvo.core.quant_utils.QuantizableLayer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="lingvo.core.base_layer.html#lingvo.core.base_layer.BaseLayer" title="lingvo.core.base_layer.BaseLayer"><code class="xref py py-class docutils literal notranslate"><span class="pre">lingvo.core.base_layer.BaseLayer</span></code></a></p>
<p>A layer that supports various forms of quantization.</p>
<p>It is always safe to extend QuantizableLayer instead of BaseLayer (i.e. at
the base of layer inheritance hierarchies) if any layer in the hierarchy
may be quantized. Unless if configured/used, all quantization behavior
is disabled by default.</p>
<p>Most quantization strategies employed at training time fall into the
“fake quantization” category, where we add various constraints in the
forward propagation to quantify and simulate the effect of quantization.
Within that, we have two major approaches:</p>
<blockquote>
<div><ul class="simple">
<li><p>Active clipping: Usually via a schedule, tensors are actively
clipped to fall into ranges that we know apriori that the model should
be able to deal with.</p></li>
<li><p>Passive tracking and simulation: Passively track the min/max ranges
of tensors and insert special ops at training and eval time that
constrain to those ranges.</p></li>
</ul>
</div></blockquote>
<p>The tensors of interest for both approaches are top-level inputs (or
embeddings), outputs of arithmetic operations (add, mul, tanh, etc) and
weights. While the actual process of quantizing can be quite complex and
involve an end to end view of the system, from a modeling perspective, it
can be thought of as providing tags/decorators to arithmetic inputs/outputs.
It would be appropriate to think of these as casts which alter the way that
the arithmetic operation is tracked and quantize (if Python/Tensorflow were
a more strongly typed environment, they would indeed represent types in the
type system but given the loose typing, it is just an honor system).</p>
<p>The “decorators” are:</p>
<ul class="simple">
<li><p>QWeight: Tags a tensor (typically a var) as a weight quantized type.</p></li>
<li><p>QR* (QRTanh, QRSigmoid, QRSoftmax, etc): Tags a tensor as the result
of a fixed activation function with a known output range (the range
is implied in the name).</p></li>
<li><p>QRPadding: Tags a tensor as containing a padding value (as we define
them as 0..1). While such values are numeric, they generally exist with
very different ranges from the rest of the graph and should not be
arithmetically combined with tensors that may have a different/variable
range.</p></li>
<li><p>QTensor: Tags a tensor as a generic quantized intermediate value.
These are also tagged with a layer-unique name. All QTensors with the
same name will be considered the same from a numerical range/precision
perspective.</p></li>
</ul>
<p>Tagging things in this way allows us to, via hyperparameters, associate
one or more quantization domains (QDomain) with the layer that will
actually perform the necessary tracking and transformations needed at
training and inference time to ensure that the layer can operate in low
bit inference engines that only have quantized numeric representations.
See the SampleQuantizedProjectionLayer in the unit test for an example layer
that has had these tags applied.</p>
<p>As a note on terminology, domain/QDomain here refers to a distinct set of
quantization rules to apply to a subset of tensors. Most layers will only
have one QDomain (default). The concept exists for layers which have been
specially created to operate in more than one quantized precision (i.e. an
RNN cell that uses 8bit quantization for inputs/outputs and 16bit
quantization for internal state arithmetic). Such uses should be rare.</p>
<p><strong>Convenience functions:</strong></p>
<p>The layer adds a number of convenience functions to the layer’s ‘fns’
function library. These mirror similarly named functions in TensorFlow but
automatically add the necessary annotations. All such functions take the
following named parameters:</p>
<blockquote>
<div><ul class="simple">
<li><p>qt: Name of QTensor (setup with TrackQTensor) for dynamic range tracking.</p></li>
<li><p>qmin/qmax/qdomain: Constant min/max range plus optional QDomain name to
resolve against. Typically, only qmin/qmax are used.</p></li>
</ul>
</div></blockquote>
<p>Functions that have a natural output range will have default values for
qmin/qmax so that they just work. Functions that do not have a natural
output range must have either qt or qmin/qmax specified manually.</p>
<p>Natural range functions</p>
<ul class="simple">
<li><p>qtanh</p></li>
<li><p>qsigmoid</p></li>
<li><p>qsoftmax</p></li>
<li><p>qrelu6</p></li>
<li><p>qrandom_uniform</p></li>
</ul>
<p>Dynamic range functions:</p>
<ul class="simple">
<li><p>qadd</p></li>
<li><p>qsubtract</p></li>
<li><p>qmultiply</p></li>
<li><p>qmatmul (defers to <a class="reference internal" href="lingvo.core.py_utils.html#lingvo.core.py_utils.Matmul" title="lingvo.core.py_utils.Matmul"><code class="xref py py-obj docutils literal notranslate"><span class="pre">py_utils.Matmul</span></code></a> and only accepts rank-2 tensors)</p></li>
<li><p>qbatchmatmul (defers to <code class="xref py py-obj docutils literal notranslate"><span class="pre">tf.matmul</span></code> directly)</p></li>
<li><p>qconv1d</p></li>
<li><p>qlog</p></li>
<li><p>qlogsoftmax</p></li>
<li><p>qrelu</p></li>
</ul>
<dl class="py method">
<dt class="sig sig-object py" id="lingvo.core.quant_utils.QuantizableLayer.Params">
<em class="property"><span class="pre">classmethod</span> </em><span class="sig-name descname"><span class="pre">Params</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/quant_utils.html#QuantizableLayer.Params"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lingvo.core.quant_utils.QuantizableLayer.Params" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lingvo.core.quant_utils.QuantizableLayer._CreateChildrenVariables">
<span class="sig-name descname"><span class="pre">_CreateChildrenVariables</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/quant_utils.html#QuantizableLayer._CreateChildrenVariables"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lingvo.core.quant_utils.QuantizableLayer._CreateChildrenVariables" title="Permalink to this definition">¶</a></dt>
<dd><p>Create variables for child layers.</p>
<p>Should be rarely overridden, only in cases when control over the context of
children InstantiateVariables calls are needed. eg, if children variables
need to be created inside of a specific context manager.</p>
<p>There are a few cases of this in the codebase marked as for backwards
compatibility. This is only to ensure that variable scopes remain compatible
through the code migration. New layers should not copy that pattern, and
instead follow the standard pattern of self.CreateChild() in __init__() and
self.CreateVariable() in _CreateLayerVariables(). If you are okay with
breaking old checkpoints, you can go ahead and delete those functions.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lingvo.core.quant_utils.QuantizableLayer.QRTanh">
<span class="sig-name descname"><span class="pre">QRTanh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">domain</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'actf'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/quant_utils.html#QuantizableLayer.QRTanh"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lingvo.core.quant_utils.QuantizableLayer.QRTanh" title="Permalink to this definition">¶</a></dt>
<dd><p>Quantizes the output of a tanh (-1.0, 1.0).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lingvo.core.quant_utils.QuantizableLayer.QRSigmoid">
<span class="sig-name descname"><span class="pre">QRSigmoid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">domain</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'actf'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/quant_utils.html#QuantizableLayer.QRSigmoid"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lingvo.core.quant_utils.QuantizableLayer.QRSigmoid" title="Permalink to this definition">¶</a></dt>
<dd><p>Quantizes the output of a sigmoid (0, 1.0).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lingvo.core.quant_utils.QuantizableLayer.QRSoftmax">
<span class="sig-name descname"><span class="pre">QRSoftmax</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">domain</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'softmax'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">narrow_to_asym_bit_depth</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/quant_utils.html#QuantizableLayer.QRSoftmax"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lingvo.core.quant_utils.QuantizableLayer.QRSoftmax" title="Permalink to this definition">¶</a></dt>
<dd><p>Quantizes the output of a softmax (0, 1.0 - 1.0/2^-bits).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lingvo.core.quant_utils.QuantizableLayer.QRRelu">
<span class="sig-name descname"><span class="pre">QRRelu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">domain</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'relu'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/quant_utils.html#QuantizableLayer.QRRelu"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lingvo.core.quant_utils.QuantizableLayer.QRRelu" title="Permalink to this definition">¶</a></dt>
<dd><p>Quantizes the output of a relu (0, 1.0).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lingvo.core.quant_utils.QuantizableLayer.QRRelu6">
<span class="sig-name descname"><span class="pre">QRRelu6</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">domain</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'relu6'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/quant_utils.html#QuantizableLayer.QRRelu6"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lingvo.core.quant_utils.QuantizableLayer.QRRelu6" title="Permalink to this definition">¶</a></dt>
<dd><p>Quantizes the output of a relu6 (0, 6.0).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lingvo.core.quant_utils.QuantizableLayer.QRPadding">
<span class="sig-name descname"><span class="pre">QRPadding</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">domain</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'padding'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/quant_utils.html#QuantizableLayer.QRPadding"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lingvo.core.quant_utils.QuantizableLayer.QRPadding" title="Permalink to this definition">¶</a></dt>
<dd><p>Quantizes the padding.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lingvo.core.quant_utils.QuantizableLayer.TrackQTensor">
<span class="sig-name descname"><span class="pre">TrackQTensor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">t_names</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/quant_utils.html#QuantizableLayer.TrackQTensor"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lingvo.core.quant_utils.QuantizableLayer.TrackQTensor" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates one or more QTensors for later use.</p>
<p>Any tensor that will later be quantized must be created first, preferably
in _CreateLayerVariables().</p>
<p>Along with a list of tensor names to create, they can be associated with
a ‘domain’. Most layers are simple enough to only have a single quantization
domain (QDomain), typically ‘default’. However, additional QDomains can
be defined as parameters to control fine grained aspects of quantization.</p>
<p>If no explicit domain is passed, then the domain (‘tensor_’ + t_name) is
tried. If that is not defined, then ‘default’.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>*t_names</strong> – Positional parameters are taken to be QTensor names to create.</p></li>
<li><p><strong>**kwargs</strong> – Can contain an explicit ‘domain’. Written this way due to
python2 limitations.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lingvo.core.quant_utils.QuantizableLayer.CreateAqtWeight">
<span class="sig-name descname"><span class="pre">CreateAqtWeight</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">w_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">feature_axis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">domain</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'weight'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">legacy_aqt_w_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/quant_utils.html#QuantizableLayer.CreateAqtWeight"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lingvo.core.quant_utils.QuantizableLayer.CreateAqtWeight" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates Quantized weights for later use.</p>
<p>Weight that will later be quantized must be created first, preferably
in _CreateLayerVariables().</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>w_name</strong> – Positional parameters are taken to be QTensor names to create.</p></li>
<li><p><strong>shape</strong> – Can contain an explicit ‘domain’. Written this way due to python2
limitations</p></li>
<li><p><strong>feature_axis</strong> – axis corresponding to output channel/feature for weights.</p></li>
<li><p><strong>domain</strong> – Custom domain to match (defaults to ‘weight’).</p></li>
<li><p><strong>legacy_aqt_w_name</strong> – Used for compatibility with old checkpoints.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lingvo.core.quant_utils.QuantizableLayer.QTensor">
<span class="sig-name descname"><span class="pre">QTensor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eval_only</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/quant_utils.html#QuantizableLayer.QTensor"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lingvo.core.quant_utils.QuantizableLayer.QTensor" title="Permalink to this definition">¶</a></dt>
<dd><p>Quantizes a general tensor input/output in one step.</p>
<p>t_name must have been previously created via TrackQTensor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>t_name</strong> – Previously created QTensor t_name to quantize to.</p></li>
<li><p><strong>t</strong> – Tensor to quantize.</p></li>
<li><p><strong>eval_only</strong> – Whether to only apply quantization pressure at eval time.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The tensor, quantized.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lingvo.core.quant_utils.QuantizableLayer.QTensorMulti">
<span class="sig-name descname"><span class="pre">QTensorMulti</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t_name</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">ts</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/quant_utils.html#QuantizableLayer.QTensorMulti"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lingvo.core.quant_utils.QuantizableLayer.QTensorMulti" title="Permalink to this definition">¶</a></dt>
<dd><p>Quantizes multiple tensors simultaneously.</p>
<p>t_name must have been previously created via TrackQTensor.</p>
<p>This is different from multiple calls to QTensor because each of the
tensors will contribute to the min/max of the same constraint.
Typically used for tensors that are being added together.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>t_name</strong> – Previously created QTensor t_name to quantize to.</p></li>
<li><p><strong>*ts</strong> – Tensor to quantize.</p></li>
<li><p><strong>**kwargs</strong> – Additional kwargs as per QTensor.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Tuple of quantized tensors.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lingvo.core.quant_utils.QuantizableLayer.GetQTensorRange">
<span class="sig-name descname"><span class="pre">GetQTensorRange</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ts</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/quant_utils.html#QuantizableLayer.GetQTensorRange"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lingvo.core.quant_utils.QuantizableLayer.GetQTensorRange" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the range for a quantized tensor.</p>
<p>t_name must have been previously create via TrackQTensor and t should be
previously quantized.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>t_name</strong> – Preivously created QTensor t_name to fetch range from.</p></li>
<li><p><strong>ts</strong> – Tensor to retrieve range from.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The (min, max) range of the quantized tensor.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lingvo.core.quant_utils.QuantizableLayer.QWeight">
<span class="sig-name descname"><span class="pre">QWeight</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">w</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">domain</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'weight'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/quant_utils.html#QuantizableLayer.QWeight"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lingvo.core.quant_utils.QuantizableLayer.QWeight" title="Permalink to this definition">¶</a></dt>
<dd><p>Quantizes a weight.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>w</strong> – The weight tensor.</p></li>
<li><p><strong>domain</strong> – Custom domain to match (defaults to ‘weight’ or ‘default’).</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The weights quantized.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lingvo.core.quant_utils.QuantizableLayer.FqWeight">
<span class="sig-name descname"><span class="pre">FqWeight</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">w_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">w</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">feature_axis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">expected_scale_shape</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/quant_utils.html#QuantizableLayer.FqWeight"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lingvo.core.quant_utils.QuantizableLayer.FqWeight" title="Permalink to this definition">¶</a></dt>
<dd><p>AQT Quantized weight FQ style.</p>
<p>This is analogous to QWeight; either AqtWeight or QWeight should be identity
for all domains. AqtQDomain additionally supports per channel quantization.</p>
<p>w_name must have been previously created via CreateAqtWeight.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>w_name</strong> – Previously created w_name QWeight to quantize weight.</p></li>
<li><p><strong>w</strong> – The weight tensor.</p></li>
<li><p><strong>feature_axis</strong> – axis corresponding to output channel/feature for weights.</p></li>
<li><p><strong>expected_scale_shape</strong> – Optional shape to verify if scale shape is as
expected. Defaults to None.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Quantized weights.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lingvo.core.quant_utils.QuantizableLayer.ToAqtWeight">
<span class="sig-name descname"><span class="pre">ToAqtWeight</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">w_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">w</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">feature_axis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">expected_scale_shape</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/quant_utils.html#QuantizableLayer.ToAqtWeight"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lingvo.core.quant_utils.QuantizableLayer.ToAqtWeight" title="Permalink to this definition">¶</a></dt>
<dd><p>Quantized integer weight AQT style.</p>
<p>This only scales, rounds and clips; resulting quantized weight would be
either integer or integer emulated in float.</p>
<p>w_name must have been previously created via CreateAqtWeight.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>w_name</strong> – Previously created w_name QWeight to quantize weight.</p></li>
<li><p><strong>w</strong> – The weight tensor.</p></li>
<li><p><strong>feature_axis</strong> – axis corresponding to output channel/feature for weights.</p></li>
<li><p><strong>expected_scale_shape</strong> – Optional shape to verify if scale shape is expected.
Defaults to None.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Quantized weights.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lingvo.core.quant_utils.QuantizableLayer.FromAqtWeight">
<span class="sig-name descname"><span class="pre">FromAqtWeight</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">w_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">merge_feature_axes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/quant_utils.html#QuantizableLayer.FromAqtWeight"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lingvo.core.quant_utils.QuantizableLayer.FromAqtWeight" title="Permalink to this definition">¶</a></dt>
<dd><p>Rescales the output corresponding to AQT style quantized matmul’s weight.</p>
<p>Uses the same scale used by <a class="reference internal" href="#lingvo.core.quant_utils.QuantizableLayer.ToAqtWeight" title="lingvo.core.quant_utils.QuantizableLayer.ToAqtWeight"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ToAqtWeight</span></code></a> and apply its inverse to rescale.</p>
<p>w_name must have been previously created via CreateAqtWeight.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>w_name</strong> – Previously created w_name QWeight to quantize weight.</p></li>
<li><p><strong>out</strong> – The tensor to rescale.</p></li>
<li><p><strong>merge_feature_axes</strong> – whether or the feature axes have been reshaped into a
single axis in ‘out’.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Rescaled output.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lingvo.core.quant_utils.QuantizableLayer.ToAqtConv">
<span class="sig-name descname"><span class="pre">ToAqtConv</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">w_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">act</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">w_feature_axis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">act_distribution</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">InputDistribution.SYMMETRIC</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">w_expected_scale_shape</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/quant_utils.html#QuantizableLayer.ToAqtConv"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lingvo.core.quant_utils.QuantizableLayer.ToAqtConv" title="Permalink to this definition">¶</a></dt>
<dd><p>Quantizes Weights and activations for convolutions.</p>
<p>Refer to quantizable_layer.ToAqtConv.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>w_name</strong> – Previously created w_name QWeight to quantize weight.</p></li>
<li><p><strong>act</strong> – The activation tensor to quantize.</p></li>
<li><p><strong>weight</strong> – The weight tensor to quantizes.</p></li>
<li><p><strong>w_feature_axis</strong> – axis corresponding to output channel/feature for weights.</p></li>
<li><p><strong>act_distribution</strong> – Distribution of act_lhs; of type InputDistribution.</p></li>
<li><p><strong>w_expected_scale_shape</strong> – Optional shape to verify if scale shape is
expected. Defaults to None.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Quantized act and weight.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lingvo.core.quant_utils.QuantizableLayer.FromAqtConv">
<span class="sig-name descname"><span class="pre">FromAqtConv</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">w_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_depthwise</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/quant_utils.html#QuantizableLayer.FromAqtConv"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lingvo.core.quant_utils.QuantizableLayer.FromAqtConv" title="Permalink to this definition">¶</a></dt>
<dd><p>Rescales the output corresponding to AQT quantized convolution.</p>
<p>Refer to quantizable_layer.FromAqtConv.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>w_name</strong> – weight name.</p></li>
<li><p><strong>output</strong> – The tensor to rescale.</p></li>
<li><p><strong>is_depthwise</strong> – Whether or not this follows a DepthwiseConv, which merges
the feature axes in the output tensor.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Rescaled output.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lingvo.core.quant_utils.QuantizableLayer.ToAqtInputs">
<span class="sig-name descname"><span class="pre">ToAqtInputs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">w_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">act</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">w_feature_axis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">act_distribution</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">InputDistribution.SYMMETRIC</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">w_expected_scale_shape</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/quant_utils.html#QuantizableLayer.ToAqtInputs"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lingvo.core.quant_utils.QuantizableLayer.ToAqtInputs" title="Permalink to this definition">¶</a></dt>
<dd><p>Quantizes weights and activations for (act * w) matmul AQT style.</p>
<p>This only scales, rounds and clips; resulting quantized inputs would be
either integer ot integer emulated in float.</p>
<p>w_name must have been previously created via CreateAqtWeight.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>w_name</strong> – Previously created w_name QWeight to quantize weight.</p></li>
<li><p><strong>act</strong> – The activation tensor to quantize.</p></li>
<li><p><strong>weight</strong> – The weight tensor to quantizes.</p></li>
<li><p><strong>w_feature_axis</strong> – axis corresponding to output channel/feature for weights.</p></li>
<li><p><strong>act_distribution</strong> – Distribution of act_lhs; of type InputDistribution.</p></li>
<li><p><strong>w_expected_scale_shape</strong> – Optional shape to verify if scale shape is
expected. Defaults to None.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Quantized act and weight.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lingvo.core.quant_utils.QuantizableLayer.FromAqtMatmul">
<span class="sig-name descname"><span class="pre">FromAqtMatmul</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">w_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/quant_utils.html#QuantizableLayer.FromAqtMatmul"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lingvo.core.quant_utils.QuantizableLayer.FromAqtMatmul" title="Permalink to this definition">¶</a></dt>
<dd><p>Rescales the output corresponding to AQT style quantized matmul.</p>
<p>Uses the same scales used by <a class="reference internal" href="#lingvo.core.quant_utils.QuantizableLayer.ToAqtInputs" title="lingvo.core.quant_utils.QuantizableLayer.ToAqtInputs"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ToAqtInputs</span></code></a> and apply its inverse to rescale.</p>
<p>w_name must have been previously created via CreateAqtWeight.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>w_name</strong> – Previously created w_name QWeight to quantize weight.</p></li>
<li><p><strong>output</strong> – The tensor to rescale.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Rescaled output.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lingvo.core.quant_utils.QuantizableLayer.ToAqtActActInputs">
<span class="sig-name descname"><span class="pre">ToAqtActActInputs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">act_lhs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">act_rhs</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">act_lhs_distribution</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'symmetric'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">act_rhs_distribution</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'symmetric'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">domain</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/quant_utils.html#QuantizableLayer.ToAqtActActInputs"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lingvo.core.quant_utils.QuantizableLayer.ToAqtActActInputs" title="Permalink to this definition">¶</a></dt>
<dd><p>Quantizes activations for (act * act) matmul AQT style.</p>
<p>This only scales, rounds and clips; resulting quantized acts would be
either integer or integer emulated in float.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>act_lhs</strong> – Left hand side activation.</p></li>
<li><p><strong>act_rhs</strong> – Right hand side activation.</p></li>
<li><p><strong>act_lhs_distribution</strong> – Distribution of act_lhs; either an InputDistribution
or a string representation of one of its members.</p></li>
<li><p><strong>act_rhs_distribution</strong> – Distribution of act_rhs; either an InputDistribution
or a string representation of one of its members.</p></li>
<li><p><strong>domain</strong> – Custom domain to match (defaults to ‘default’).</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Quantized activations corresponding to act_lhs and act_rhs.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lingvo.core.quant_utils.QuantizableLayer.FromAqtActActMatmul">
<span class="sig-name descname"><span class="pre">FromAqtActActMatmul</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">output</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">domain</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/quant_utils.html#QuantizableLayer.FromAqtActActMatmul"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lingvo.core.quant_utils.QuantizableLayer.FromAqtActActMatmul" title="Permalink to this definition">¶</a></dt>
<dd><p>Rescales the output of (act*act) matmul for AQT style quantized acts.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>output</strong> – Previously created w_name QWeight to quantize weight.</p></li>
<li><p><strong>domain</strong> – Custom domain to match (defaults to ‘default’).</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Rescaled output.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lingvo.core.quant_utils.QuantizableLayer.GetQDomain">
<span class="sig-name descname"><span class="pre">GetQDomain</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">domain</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/quant_utils.html#QuantizableLayer.GetQDomain"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lingvo.core.quant_utils.QuantizableLayer.GetQDomain" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the QDomain matching a given domain name.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>domain</strong> – User specified domain name.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The requested QDomain, the ‘default’ QDomain or None.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lingvo.core.quant_utils.QuantizableLayer.GetQDomainParams">
<span class="sig-name descname"><span class="pre">GetQDomainParams</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">domain</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/quant_utils.html#QuantizableLayer.GetQDomainParams"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lingvo.core.quant_utils.QuantizableLayer.GetQDomainParams" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets domain’s Params if they’re set, and the default Params otherwise.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>domain</strong> – User specified domain name.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Params for the QDomain matching the requested domain name if they’re set,
and params for the ‘default’ QDomain otherwise. Will return None if both
p.qdomain.domain and p.qdomain.default are None.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lingvo.core.quant_utils.QuantizableLayer._AddQuantizationFunctions">
<span class="sig-name descname"><span class="pre">_AddQuantizationFunctions</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/quant_utils.html#QuantizableLayer._AddQuantizationFunctions"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lingvo.core.quant_utils.QuantizableLayer._AddQuantizationFunctions" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds standard quantization functions against the given layer.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="lingvo.core.quant_utils.BaseClippingCapSchedule">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">lingvo.core.quant_utils.</span></span><span class="sig-name descname"><span class="pre">BaseClippingCapSchedule</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/quant_utils.html#BaseClippingCapSchedule"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lingvo.core.quant_utils.BaseClippingCapSchedule" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="lingvo.core.base_layer.html#lingvo.core.base_layer.BaseLayer" title="lingvo.core.base_layer.BaseLayer"><code class="xref py py-class docutils literal notranslate"><span class="pre">lingvo.core.base_layer.BaseLayer</span></code></a></p>
<p>Base class for clipping cap schedules.</p>
<dl class="py property">
<dt class="sig sig-object py" id="lingvo.core.quant_utils.BaseClippingCapSchedule.is_quantized">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">is_quantized</span></span><a class="headerlink" href="#lingvo.core.quant_utils.BaseClippingCapSchedule.is_quantized" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lingvo.core.quant_utils.BaseClippingCapSchedule.GetEndRange">
<span class="sig-name descname"><span class="pre">GetEndRange</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/quant_utils.html#BaseClippingCapSchedule.GetEndRange"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lingvo.core.quant_utils.BaseClippingCapSchedule.GetEndRange" title="Permalink to this definition">¶</a></dt>
<dd><p>Public method to get the final range as a constant.</p>
<p>Note that this returns the “ideal” end range (i.e. -1..1) as opposed to
the actual range, which has its upper bound slightly adjusted based on
the bit depth of the quantized type. In this sense, this value is a lie,
but it is a consistent lie that can be corrected for downstream by the
inference engine once it has inferred the actual quantized types being
used.</p>
<p>Note that this also assumes the default start/end caps. Some internal
parts may use altered caps or bit depths.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Tuple of (min, max) for the final range.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lingvo.core.quant_utils.BaseClippingCapSchedule.GetQuantizedEndRange">
<span class="sig-name descname"><span class="pre">GetQuantizedEndRange</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/quant_utils.html#BaseClippingCapSchedule.GetQuantizedEndRange"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lingvo.core.quant_utils.BaseClippingCapSchedule.GetQuantizedEndRange" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the quantized ending range.</p>
<p>Unlike GetEndRange(), this takes quantization effects into account.
The default implementation just returns self.GetEndRange(). Subclasses
can include additional keyword arguments, tightly coupling them to callers
of specific types.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Tuple of (min, max) for the final range.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lingvo.core.quant_utils.BaseClippingCapSchedule.ApplyConstantClip">
<span class="sig-name descname"><span class="pre">ApplyConstantClip</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_value</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_value</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/quant_utils.html#BaseClippingCapSchedule.ApplyConstantClip"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lingvo.core.quant_utils.BaseClippingCapSchedule.ApplyConstantClip" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies a constant clip with the clipping op for the implementation.</p>
<p>This is a special case which allows applying a custom clipping range to
constants that are not used arithmetically. This exists to support padding.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> – Tensor to clip.</p></li>
<li><p><strong>min_value</strong> – Minimum value.</p></li>
<li><p><strong>max_value</strong> – Maximum value.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Tensor clipped.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lingvo.core.quant_utils.BaseClippingCapSchedule.GetState">
<span class="sig-name descname"><span class="pre">GetState</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">theta</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/quant_utils.html#BaseClippingCapSchedule.GetState"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lingvo.core.quant_utils.BaseClippingCapSchedule.GetState" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets a state tensor that can be used to calculate clipping.</p>
<p>The state will be a float32 tensor that is safe to pass to TF functions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>theta</strong> – Layer theta.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>An opaque tensor to be passed to ApplyClippingWithState().</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lingvo.core.quant_utils.BaseClippingCapSchedule.ApplyClipping">
<span class="sig-name descname"><span class="pre">ApplyClipping</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">theta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/quant_utils.html#BaseClippingCapSchedule.ApplyClipping"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lingvo.core.quant_utils.BaseClippingCapSchedule.ApplyClipping" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies clipping to x.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>theta</strong> – Layer theta.</p></li>
<li><p><strong>x</strong> – Input tensor to clip.</p></li>
<li><p><strong>**kwargs</strong> – Additional implementation specific kwargs.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Clipped (or identity) x.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lingvo.core.quant_utils.BaseClippingCapSchedule.ApplyClippingWithState">
<span class="sig-name descname"><span class="pre">ApplyClippingWithState</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/quant_utils.html#BaseClippingCapSchedule.ApplyClippingWithState"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lingvo.core.quant_utils.BaseClippingCapSchedule.ApplyClippingWithState" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies clipping to x.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>state</strong> – A previously obtained value of GetState().</p></li>
<li><p><strong>x</strong> – Input tensor to clip.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Clipped (or identity) x.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="lingvo.core.quant_utils.IdentityClippingCapSchedule">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">lingvo.core.quant_utils.</span></span><span class="sig-name descname"><span class="pre">IdentityClippingCapSchedule</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/quant_utils.html#IdentityClippingCapSchedule"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lingvo.core.quant_utils.IdentityClippingCapSchedule" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#lingvo.core.quant_utils.BaseClippingCapSchedule" title="lingvo.core.quant_utils.BaseClippingCapSchedule"><code class="xref py py-class docutils literal notranslate"><span class="pre">lingvo.core.quant_utils.BaseClippingCapSchedule</span></code></a></p>
<p>Dummy cc schedule (useful in some cases instead of None).</p>
<dl class="py method">
<dt class="sig sig-object py" id="lingvo.core.quant_utils.IdentityClippingCapSchedule.GetEndRange">
<span class="sig-name descname"><span class="pre">GetEndRange</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/quant_utils.html#IdentityClippingCapSchedule.GetEndRange"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lingvo.core.quant_utils.IdentityClippingCapSchedule.GetEndRange" title="Permalink to this definition">¶</a></dt>
<dd><p>Public method to get the final range as a constant.</p>
<p>Note that this returns the “ideal” end range (i.e. -1..1) as opposed to
the actual range, which has its upper bound slightly adjusted based on
the bit depth of the quantized type. In this sense, this value is a lie,
but it is a consistent lie that can be corrected for downstream by the
inference engine once it has inferred the actual quantized types being
used.</p>
<p>Note that this also assumes the default start/end caps. Some internal
parts may use altered caps or bit depths.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Tuple of (min, max) for the final range.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lingvo.core.quant_utils.IdentityClippingCapSchedule.ApplyConstantClip">
<span class="sig-name descname"><span class="pre">ApplyConstantClip</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_value</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_value</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/quant_utils.html#IdentityClippingCapSchedule.ApplyConstantClip"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lingvo.core.quant_utils.IdentityClippingCapSchedule.ApplyConstantClip" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies a constant clip with the clipping op for the implementation.</p>
<p>This is a special case which allows applying a custom clipping range to
constants that are not used arithmetically. This exists to support padding.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> – Tensor to clip.</p></li>
<li><p><strong>min_value</strong> – Minimum value.</p></li>
<li><p><strong>max_value</strong> – Maximum value.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Tensor clipped.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lingvo.core.quant_utils.IdentityClippingCapSchedule.GetState">
<span class="sig-name descname"><span class="pre">GetState</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">theta</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/quant_utils.html#IdentityClippingCapSchedule.GetState"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lingvo.core.quant_utils.IdentityClippingCapSchedule.GetState" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets a state tensor that can be used to calculate clipping.</p>
<p>The state will be a float32 tensor that is safe to pass to TF functions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>theta</strong> – Layer theta.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>An opaque tensor to be passed to ApplyClippingWithState().</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lingvo.core.quant_utils.IdentityClippingCapSchedule.ApplyClippingWithState">
<span class="sig-name descname"><span class="pre">ApplyClippingWithState</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/quant_utils.html#IdentityClippingCapSchedule.ApplyClippingWithState"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lingvo.core.quant_utils.IdentityClippingCapSchedule.ApplyClippingWithState" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies clipping to x.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>state</strong> – A previously obtained value of GetState().</p></li>
<li><p><strong>x</strong> – Input tensor to clip.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Clipped (or identity) x.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="lingvo.core.quant_utils.LinearClippingCapSchedule">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">lingvo.core.quant_utils.</span></span><span class="sig-name descname"><span class="pre">LinearClippingCapSchedule</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/quant_utils.html#LinearClippingCapSchedule"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lingvo.core.quant_utils.LinearClippingCapSchedule" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#lingvo.core.quant_utils.BaseClippingCapSchedule" title="lingvo.core.quant_utils.BaseClippingCapSchedule"><code class="xref py py-class docutils literal notranslate"><span class="pre">lingvo.core.quant_utils.BaseClippingCapSchedule</span></code></a></p>
<p>Class for linear clipping cap decay.</p>
<dl class="py method">
<dt class="sig sig-object py" id="lingvo.core.quant_utils.LinearClippingCapSchedule.Params">
<em class="property"><span class="pre">classmethod</span> </em><span class="sig-name descname"><span class="pre">Params</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/quant_utils.html#LinearClippingCapSchedule.Params"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lingvo.core.quant_utils.LinearClippingCapSchedule.Params" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="lingvo.core.quant_utils.LinearClippingCapSchedule.is_quantized">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">is_quantized</span></span><a class="headerlink" href="#lingvo.core.quant_utils.LinearClippingCapSchedule.is_quantized" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lingvo.core.quant_utils.LinearClippingCapSchedule.ApplyConstantClip">
<span class="sig-name descname"><span class="pre">ApplyConstantClip</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_value</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_value</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/quant_utils.html#LinearClippingCapSchedule.ApplyConstantClip"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lingvo.core.quant_utils.LinearClippingCapSchedule.ApplyConstantClip" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies a constant clip with the clipping op for the implementation.</p>
<p>This is a special case which allows applying a custom clipping range to
constants that are not used arithmetically. This exists to support padding.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> – Tensor to clip.</p></li>
<li><p><strong>min_value</strong> – Minimum value.</p></li>
<li><p><strong>max_value</strong> – Maximum value.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Tensor clipped.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lingvo.core.quant_utils.LinearClippingCapSchedule.GetState">
<span class="sig-name descname"><span class="pre">GetState</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">theta</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/quant_utils.html#LinearClippingCapSchedule.GetState"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lingvo.core.quant_utils.LinearClippingCapSchedule.GetState" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets a state tensor that can be used to calculate clipping.</p>
<p>The state will be a float32 tensor that is safe to pass to TF functions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>theta</strong> – Layer theta.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>An opaque tensor to be passed to ApplyClippingWithState().</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lingvo.core.quant_utils.LinearClippingCapSchedule.ApplyClippingWithState">
<span class="sig-name descname"><span class="pre">ApplyClippingWithState</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/quant_utils.html#LinearClippingCapSchedule.ApplyClippingWithState"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lingvo.core.quant_utils.LinearClippingCapSchedule.ApplyClippingWithState" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies clipping to x.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>state</strong> – Clipping state.</p></li>
<li><p><strong>x</strong> – Input tensor to clip.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Clipped (or identity) x.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lingvo.core.quant_utils.LinearClippingCapSchedule.GetEndRange">
<span class="sig-name descname"><span class="pre">GetEndRange</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/quant_utils.html#LinearClippingCapSchedule.GetEndRange"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lingvo.core.quant_utils.LinearClippingCapSchedule.GetEndRange" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the range of values that are clipped towards the end of training.</p>
<p>This is always a constant and is used by downstream systems.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Tuple of (min, max).</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lingvo.core.quant_utils.LinearClippingCapSchedule._Value">
<span class="sig-name descname"><span class="pre">_Value</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/quant_utils.html#LinearClippingCapSchedule._Value"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lingvo.core.quant_utils.LinearClippingCapSchedule._Value" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the current clipping cap.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="lingvo.core.quant_utils.FakeQuantizationSchedule">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">lingvo.core.quant_utils.</span></span><span class="sig-name descname"><span class="pre">FakeQuantizationSchedule</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/quant_utils.html#FakeQuantizationSchedule"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lingvo.core.quant_utils.FakeQuantizationSchedule" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#lingvo.core.quant_utils.BaseClippingCapSchedule" title="lingvo.core.quant_utils.BaseClippingCapSchedule"><code class="xref py py-class docutils literal notranslate"><span class="pre">lingvo.core.quant_utils.BaseClippingCapSchedule</span></code></a></p>
<p>Manages application of fake quantization via a schedule.</p>
<p>This implementation is a general-purpose clipping cap schedule but also
works with the Fake Quantization approach used by mobile inference engines.
It is tightly coupled to the FakeQuantizedLSTMCell. See more exhaustive
documentation and links there.</p>
<dl class="py method">
<dt class="sig sig-object py" id="lingvo.core.quant_utils.FakeQuantizationSchedule.Params">
<em class="property"><span class="pre">classmethod</span> </em><span class="sig-name descname"><span class="pre">Params</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/quant_utils.html#FakeQuantizationSchedule.Params"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lingvo.core.quant_utils.FakeQuantizationSchedule.Params" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="lingvo.core.quant_utils.FakeQuantizationSchedule.is_quantized">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">is_quantized</span></span><a class="headerlink" href="#lingvo.core.quant_utils.FakeQuantizationSchedule.is_quantized" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="lingvo.core.quant_utils.FakeQuantizationSchedule.bits">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">bits</span></span><a class="headerlink" href="#lingvo.core.quant_utils.FakeQuantizationSchedule.bits" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lingvo.core.quant_utils.FakeQuantizationSchedule.GetEndRange">
<span class="sig-name descname"><span class="pre">GetEndRange</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/quant_utils.html#FakeQuantizationSchedule.GetEndRange"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lingvo.core.quant_utils.FakeQuantizationSchedule.GetEndRange" title="Permalink to this definition">¶</a></dt>
<dd><p>Public method to get the final range as a constant.</p>
<p>Note that this returns the “ideal” end range (i.e. -1..1) as opposed to
the actual range, which has its upper bound slightly adjusted based on
the bit depth of the quantized type. In this sense, this value is a lie,
but it is a consistent lie that can be corrected for downstream by the
inference engine once it has inferred the actual quantized types being
used.</p>
<p>Note that this also assumes the default start/end caps. Some internal
parts may use altered caps or bit depths.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Tuple of (min, max) for the final range.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lingvo.core.quant_utils.FakeQuantizationSchedule.GetQuantizedEndRange">
<span class="sig-name descname"><span class="pre">GetQuantizedEndRange</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">end_cap</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bits</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/quant_utils.html#FakeQuantizationSchedule.GetQuantizedEndRange"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lingvo.core.quant_utils.FakeQuantizationSchedule.GetQuantizedEndRange" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the quantized ending range.</p>
<p>Unlike GetEndRange(), this takes quantization effects into account.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>end_cap</strong> – Override end_cap value.</p></li>
<li><p><strong>bits</strong> – Override bits value.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Tuple of (min, max) for the final range.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lingvo.core.quant_utils.FakeQuantizationSchedule.ApplyConstantClip">
<span class="sig-name descname"><span class="pre">ApplyConstantClip</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_value</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_value</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/quant_utils.html#FakeQuantizationSchedule.ApplyConstantClip"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lingvo.core.quant_utils.FakeQuantizationSchedule.ApplyConstantClip" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies a constant clip with the clipping op for the implementation.</p>
<p>This is a special case which allows applying a custom clipping range to
constants that are not used arithmetically. This exists to support padding.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> – Tensor to clip.</p></li>
<li><p><strong>min_value</strong> – Minimum value.</p></li>
<li><p><strong>max_value</strong> – Maximum value.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Tensor clipped.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lingvo.core.quant_utils.FakeQuantizationSchedule.GetState">
<span class="sig-name descname"><span class="pre">GetState</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">theta</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/quant_utils.html#FakeQuantizationSchedule.GetState"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lingvo.core.quant_utils.FakeQuantizationSchedule.GetState" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the state from theta.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lingvo.core.quant_utils.FakeQuantizationSchedule._GetQuantizedRangeForCap">
<span class="sig-name descname"><span class="pre">_GetQuantizedRangeForCap</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">current_cap</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bits</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/quant_utils.html#FakeQuantizationSchedule._GetQuantizedRangeForCap"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lingvo.core.quant_utils.FakeQuantizationSchedule._GetQuantizedRangeForCap" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the range for the given cap and number of bits.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>current_cap</strong> – Cap to compute against.</p></li>
<li><p><strong>bits</strong> – Number of bits (8, 16, etc).</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>If current_cap is a python float, the result will be a float. If a Tensor
scalar, then a Tensor scalar.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lingvo.core.quant_utils.FakeQuantizationSchedule._GetCurrentMinMax">
<span class="sig-name descname"><span class="pre">_GetCurrentMinMax</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start_cap</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">end_cap</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bits</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fixate_to_end_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/quant_utils.html#FakeQuantizationSchedule._GetCurrentMinMax"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lingvo.core.quant_utils.FakeQuantizationSchedule._GetCurrentMinMax" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the current min/max for the bit depth and caps.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>state</strong> – Clipping state.</p></li>
<li><p><strong>start_cap</strong> – Starting cap.</p></li>
<li><p><strong>end_cap</strong> – Ending cap once clipping saturates.</p></li>
<li><p><strong>bits</strong> – Number of bits of the quantized datatype.</p></li>
<li><p><strong>fixate_to_end_state</strong> – Whether to fixate the cap to the end state.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><dl class="simple">
<dt>(min_value, max_value) as python scalars or 0D Tensors (</dt><dd><p>if not fixate_to_end_state).</p>
</dd>
</dl>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lingvo.core.quant_utils.FakeQuantizationSchedule.ApplyClippingWithState">
<span class="sig-name descname"><span class="pre">ApplyClippingWithState</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start_cap</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">end_cap</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bits</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/quant_utils.html#FakeQuantizationSchedule.ApplyClippingWithState"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lingvo.core.quant_utils.FakeQuantizationSchedule.ApplyClippingWithState" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies clipping.</p>
<p>The start_cap, end_cap and bits can be set explicitly and take the default
if None.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>state</strong> – Clipping state.</p></li>
<li><p><strong>x</strong> – Tensor to clip.</p></li>
<li><p><strong>start_cap</strong> – Clipping value at the start of the ramp.</p></li>
<li><p><strong>end_cap</strong> – Clipping value at the end of the ramp.</p></li>
<li><p><strong>bits</strong> – Number of bits to quantize to.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>x with clipping applied.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="lingvo.core.quant_utils.QDomain">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">lingvo.core.quant_utils.</span></span><span class="sig-name descname"><span class="pre">QDomain</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/quant_utils.html#QDomain"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lingvo.core.quant_utils.QDomain" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="lingvo.core.base_layer.html#lingvo.core.base_layer.BaseLayer" title="lingvo.core.base_layer.BaseLayer"><code class="xref py py-class docutils literal notranslate"><span class="pre">lingvo.core.base_layer.BaseLayer</span></code></a></p>
<p>Base class for a quantization domain layer.</p>
<p>This implementation doubles as a no-op quantization domain.</p>
<dl class="py property">
<dt class="sig sig-object py" id="lingvo.core.quant_utils.QDomain.bits">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">bits</span></span><a class="headerlink" href="#lingvo.core.quant_utils.QDomain.bits" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieves the bits used by this quantization layer.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The number of bits available to this qdomain or None if unquantized.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lingvo.core.quant_utils.QDomain.QuantizeWeight">
<span class="sig-name descname"><span class="pre">QuantizeWeight</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">w</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/quant_utils.html#QDomain.QuantizeWeight"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lingvo.core.quant_utils.QDomain.QuantizeWeight" title="Permalink to this definition">¶</a></dt>
<dd><p>Quantizes a weight.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>w</strong> – Weight tensor to quantize.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Quantized weight.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lingvo.core.quant_utils.QDomain.ToAqtConv">
<span class="sig-name descname"><span class="pre">ToAqtConv</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">w_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">act</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">w_feature_axis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">act_distribution</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">w_expected_scale_shape</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/quant_utils.html#QDomain.ToAqtConv"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lingvo.core.quant_utils.QDomain.ToAqtConv" title="Permalink to this definition">¶</a></dt>
<dd><p>Quantizes Weights and activations for convolutions.</p>
<p>Refer to quantizable_layer.ToAqtConv.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>w_name</strong> – Previously created w_name QWeight to quantize weight.</p></li>
<li><p><strong>act</strong> – The activation tensor to quantize.</p></li>
<li><p><strong>weight</strong> – The weight tensor to quantizes.</p></li>
<li><p><strong>w_feature_axis</strong> – axis corresponding to output channel/feature for weights.</p></li>
<li><p><strong>act_distribution</strong> – Distribution of act_lhs; of type InputDistribution.</p></li>
<li><p><strong>w_expected_scale_shape</strong> – Optional shape to verify if scale shape is
expected. Defaults to None.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Quantized act and weight.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lingvo.core.quant_utils.QDomain.FromAqtConv">
<span class="sig-name descname"><span class="pre">FromAqtConv</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">w_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_depthwise</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/quant_utils.html#QDomain.FromAqtConv"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lingvo.core.quant_utils.QDomain.FromAqtConv" title="Permalink to this definition">¶</a></dt>
<dd><p>Rescales the output corresponding to AQT quantized convolution.</p>
<p>Refer to quantizable_layer.FromAqtConv.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>w_name</strong> – weight name.</p></li>
<li><p><strong>output</strong> – The tensor to rescale.</p></li>
<li><p><strong>is_depthwise</strong> – Whether or not this follows a DepthwiseConv, which merges
the feature axes in the output tensor.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Rescaled output.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lingvo.core.quant_utils.QDomain.ToAqtInputs">
<span class="sig-name descname"><span class="pre">ToAqtInputs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">w_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">act</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">w_feature_axis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">act_distribution</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">w_expected_scale_shape</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/quant_utils.html#QDomain.ToAqtInputs"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lingvo.core.quant_utils.QDomain.ToAqtInputs" title="Permalink to this definition">¶</a></dt>
<dd><p>Quantizes weights and activations for (act * w) matmul AQT style.</p>
<p>Refer to quantizable_layer.ToAqtInputs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>w_name</strong> – Previously created w_name QWeight to quantize weight.</p></li>
<li><p><strong>act</strong> – The activation tensor to quantize.</p></li>
<li><p><strong>weight</strong> – The weight tensor to quantizes.</p></li>
<li><p><strong>w_feature_axis</strong> – axis corresponding to output channel/feature for weights.</p></li>
<li><p><strong>act_distribution</strong> – Distribution of act_lhs; of type InputDistribution.</p></li>
<li><p><strong>w_expected_scale_shape</strong> – Optional shape to verify if scale shape is
expected. Defaults to None.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Quantized act and weight.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lingvo.core.quant_utils.QDomain.FromAqtMatmul">
<span class="sig-name descname"><span class="pre">FromAqtMatmul</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">w_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/quant_utils.html#QDomain.FromAqtMatmul"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lingvo.core.quant_utils.QDomain.FromAqtMatmul" title="Permalink to this definition">¶</a></dt>
<dd><p>Rescales the output corresponding to AQT quantized matmuls.</p>
<p>Refer to quantizable_layer.FromAqtOutput.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>w_name</strong> – weight name.</p></li>
<li><p><strong>output</strong> – The tensor to rescale.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Rescaled output.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lingvo.core.quant_utils.QDomain.FqWeight">
<span class="sig-name descname"><span class="pre">FqWeight</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">w_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">w</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">feature_axis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">expected_scale_shape</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/quant_utils.html#QDomain.FqWeight"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lingvo.core.quant_utils.QDomain.FqWeight" title="Permalink to this definition">¶</a></dt>
<dd><p>AQT Quantized weight FQ style .</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>w_name</strong> – weight name.</p></li>
<li><p><strong>w</strong> – The weight tensor.</p></li>
<li><p><strong>feature_axis</strong> – axis corresponding to output channel/feature for weights.</p></li>
<li><p><strong>expected_scale_shape</strong> – Optional shape to verify if scale shape is expected.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Quantized weights.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lingvo.core.quant_utils.QDomain.ToAqtWeight">
<span class="sig-name descname"><span class="pre">ToAqtWeight</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">w_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">w</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">feature_axis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">expected_scale_shape</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/quant_utils.html#QDomain.ToAqtWeight"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lingvo.core.quant_utils.QDomain.ToAqtWeight" title="Permalink to this definition">¶</a></dt>
<dd><p>Quantized weight AQT style.</p>
<p>Refer to quantizable_layer.ToAqtWeight.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>w_name</strong> – weight name.</p></li>
<li><p><strong>w</strong> – The weight tensor.</p></li>
<li><p><strong>feature_axis</strong> – axis corresponding to output channel/feature for weights.</p></li>
<li><p><strong>expected_scale_shape</strong> – Optional shape to verify if scale shape is expected.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Quantized weights.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lingvo.core.quant_utils.QDomain.FromAqtWeight">
<span class="sig-name descname"><span class="pre">FromAqtWeight</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">w_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">merge_feature_axes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/quant_utils.html#QDomain.FromAqtWeight"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lingvo.core.quant_utils.QDomain.FromAqtWeight" title="Permalink to this definition">¶</a></dt>
<dd><p>Rescales the output corresponding to AQT quantized matmuls’ weight.</p>
<p>Refer to quantizable_layer.FromAqtWeight.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>w_name</strong> – weight name.</p></li>
<li><p><strong>out</strong> – The tensor to rescale.</p></li>
<li><p><strong>merge_feature_axes</strong> – whether or the feature axes have been reshaped into a
single axis in ‘out’.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Rescaled output.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lingvo.core.quant_utils.QDomain.ToAqtActActInputs">
<span class="sig-name descname"><span class="pre">ToAqtActActInputs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">act_lhs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">act_rhs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">act_lhs_distribution</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">act_rhs_distribution</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/quant_utils.html#QDomain.ToAqtActActInputs"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lingvo.core.quant_utils.QDomain.ToAqtActActInputs" title="Permalink to this definition">¶</a></dt>
<dd><p>Quantizes activations for (act * act) matmul AQT style.</p>
<p>This only scales, rounds and clips; resulting quantized acts would be
either integer or integer emulated in float.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>act_lhs</strong> – Left hand side activation.</p></li>
<li><p><strong>act_rhs</strong> – Right hand side activation.</p></li>
<li><p><strong>act_lhs_distribution</strong> – Distribution of act_lhs; of type InputDistribution.</p></li>
<li><p><strong>act_rhs_distribution</strong> – Distribution of act_rhs; of type InputDistribution.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Quantized activations corresponding to act_lhs and act_rhs.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lingvo.core.quant_utils.QDomain.FromAqtActActMatmul">
<span class="sig-name descname"><span class="pre">FromAqtActActMatmul</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">output</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/quant_utils.html#QDomain.FromAqtActActMatmul"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lingvo.core.quant_utils.QDomain.FromAqtActActMatmul" title="Permalink to this definition">¶</a></dt>
<dd><p>Rescales output of dynamic matmul (act * act).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>output</strong> – output, corresponds to tf.matmul(act_lhs, act_rhs)</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Rescaled output.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lingvo.core.quant_utils.QDomain.QuantizeConstantRange">
<span class="sig-name descname"><span class="pre">QuantizeConstantRange</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_value</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_value</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/quant_utils.html#QDomain.QuantizeConstantRange"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lingvo.core.quant_utils.QDomain.QuantizeConstantRange" title="Permalink to this definition">¶</a></dt>
<dd><p>Quantizes a true-constant range that is not used for arithmetic.</p>
<p>This supports special values like padding that should have a precise
range that we do not deviate from.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>t</strong> – Tensor to quantize.</p></li>
<li><p><strong>min_value</strong> – Min of the range.</p></li>
<li><p><strong>max_value</strong> – Max of the range.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Quantized tensor.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lingvo.core.quant_utils.QDomain.QuantizeNaturalRange">
<span class="sig-name descname"><span class="pre">QuantizeNaturalRange</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_value</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_value</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/quant_utils.html#QDomain.QuantizeNaturalRange"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lingvo.core.quant_utils.QDomain.QuantizeNaturalRange" title="Permalink to this definition">¶</a></dt>
<dd><p>Quantizes a tensor with a known, natural range.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>t</strong> – Tensor to quantize.</p></li>
<li><p><strong>min_value</strong> – Min value of the range.</p></li>
<li><p><strong>max_value</strong> – Max value of the range.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Quantized tensor.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lingvo.core.quant_utils.QDomain.CreateTensor">
<span class="sig-name descname"><span class="pre">CreateTensor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t_name</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/quant_utils.html#QDomain.CreateTensor"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lingvo.core.quant_utils.QDomain.CreateTensor" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a QTensor with t_name.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>t_name</strong> – Unique name (within layer) for this tensor.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lingvo.core.quant_utils.QDomain.CreateTensorWithShape">
<span class="sig-name descname"><span class="pre">CreateTensorWithShape</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">feature_axis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">legacy_aqt_t_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/quant_utils.html#QDomain.CreateTensorWithShape"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lingvo.core.quant_utils.QDomain.CreateTensorWithShape" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a QTensor with t_name and given shape.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>t_name</strong> – Unique name (within layer) for this tensor.</p></li>
<li><p><strong>shape</strong> – Expected shape of the tensor.</p></li>
<li><p><strong>feature_axis</strong> – axis corresponding to output channel/feature for weights.</p></li>
<li><p><strong>legacy_aqt_t_name</strong> – Used for compatibility with old checkpoints.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lingvo.core.quant_utils.QDomain.QuantizeTensors">
<span class="sig-name descname"><span class="pre">QuantizeTensors</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ts</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eval_only</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/quant_utils.html#QDomain.QuantizeTensors"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lingvo.core.quant_utils.QDomain.QuantizeTensors" title="Permalink to this definition">¶</a></dt>
<dd><p>Quantizes a tensor with t_name previously created with CreateTensor.</p>
<p>If applicable, each of the passed tensors contributes to a shared
range.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>t_name</strong> – Tensor name.</p></li>
<li><p><strong>ts</strong> – List of tensors to quantize.</p></li>
<li><p><strong>eval_only</strong> – Whether to only apply quantization pressure at eval time.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Quantized tensors.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lingvo.core.quant_utils.QDomain.GetTensorRange">
<span class="sig-name descname"><span class="pre">GetTensorRange</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ts</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/quant_utils.html#QDomain.GetTensorRange"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lingvo.core.quant_utils.QDomain.GetTensorRange" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieves the range of a tensor given the t_name used by CreateTensor.</p>
<p>Note, this computes the batch range across the list of tensors at training
time but fetches the stored tensor over time. This depends on
QuantizeTensors updating the appropriate value.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>t_name</strong> – Tensor name.</p></li>
<li><p><strong>ts</strong> – Tensor to determine the range for.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A min-max pair that represents the tensor range.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="lingvo.core.quant_utils.SymmetricScheduledClipQDomain">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">lingvo.core.quant_utils.</span></span><span class="sig-name descname"><span class="pre">SymmetricScheduledClipQDomain</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/quant_utils.html#SymmetricScheduledClipQDomain"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lingvo.core.quant_utils.SymmetricScheduledClipQDomain" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#lingvo.core.quant_utils.QDomain" title="lingvo.core.quant_utils.QDomain"><code class="xref py py-class docutils literal notranslate"><span class="pre">lingvo.core.quant_utils.QDomain</span></code></a></p>
<p>A quantization domain that does symmetric scheduled clipping.</p>
<p>This contains a BaseClippingCapSchedule which handles the actual clipping. It
defaults to a FakeQuantizationSchedule.</p>
<p>This clipping domain will aid in quantizing layers that are known to tolerate
operation within known ranges (such as LSTM cells). The clipping range will
converge over a range of steps and is setup to match ideal, symmetric ranges
for quantized types.</p>
<dl class="py method">
<dt class="sig sig-object py" id="lingvo.core.quant_utils.SymmetricScheduledClipQDomain.Params">
<em class="property"><span class="pre">classmethod</span> </em><span class="sig-name descname"><span class="pre">Params</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/quant_utils.html#SymmetricScheduledClipQDomain.Params"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lingvo.core.quant_utils.SymmetricScheduledClipQDomain.Params" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="lingvo.core.quant_utils.SymmetricScheduledClipQDomain.bits">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">bits</span></span><a class="headerlink" href="#lingvo.core.quant_utils.SymmetricScheduledClipQDomain.bits" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieves the bits used by this quantization layer.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The number of bits available to this qdomain or None if unquantized.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lingvo.core.quant_utils.SymmetricScheduledClipQDomain.QuantizeWeight">
<span class="sig-name descname"><span class="pre">QuantizeWeight</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">w</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/quant_utils.html#SymmetricScheduledClipQDomain.QuantizeWeight"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lingvo.core.quant_utils.SymmetricScheduledClipQDomain.QuantizeWeight" title="Permalink to this definition">¶</a></dt>
<dd><p>Quantizes a weight.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>w</strong> – Weight tensor to quantize.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Quantized weight.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lingvo.core.quant_utils.SymmetricScheduledClipQDomain.QuantizeNaturalRange">
<span class="sig-name descname"><span class="pre">QuantizeNaturalRange</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_value</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_value</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/quant_utils.html#SymmetricScheduledClipQDomain.QuantizeNaturalRange"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lingvo.core.quant_utils.SymmetricScheduledClipQDomain.QuantizeNaturalRange" title="Permalink to this definition">¶</a></dt>
<dd><p>Quantizes a tensor with a known, natural range.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>t</strong> – Tensor to quantize.</p></li>
<li><p><strong>min_value</strong> – Min value of the range.</p></li>
<li><p><strong>max_value</strong> – Max value of the range.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Quantized tensor.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lingvo.core.quant_utils.SymmetricScheduledClipQDomain.QuantizeConstantRange">
<span class="sig-name descname"><span class="pre">QuantizeConstantRange</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_value</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_value</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/quant_utils.html#SymmetricScheduledClipQDomain.QuantizeConstantRange"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lingvo.core.quant_utils.SymmetricScheduledClipQDomain.QuantizeConstantRange" title="Permalink to this definition">¶</a></dt>
<dd><p>Quantizes a true-constant range that is not used for arithmetic.</p>
<p>This supports special values like padding that should have a precise
range that we do not deviate from.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>t</strong> – Tensor to quantize.</p></li>
<li><p><strong>min_value</strong> – Min of the range.</p></li>
<li><p><strong>max_value</strong> – Max of the range.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Quantized tensor.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lingvo.core.quant_utils.SymmetricScheduledClipQDomain.QuantizeTensors">
<span class="sig-name descname"><span class="pre">QuantizeTensors</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ts</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eval_only</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/quant_utils.html#SymmetricScheduledClipQDomain.QuantizeTensors"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lingvo.core.quant_utils.SymmetricScheduledClipQDomain.QuantizeTensors" title="Permalink to this definition">¶</a></dt>
<dd><p>Quantizes a tensor with t_name previously created with CreateTensor.</p>
<p>If applicable, each of the passed tensors contributes to a shared
range.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>t_name</strong> – Tensor name.</p></li>
<li><p><strong>ts</strong> – List of tensors to quantize.</p></li>
<li><p><strong>eval_only</strong> – Whether to only apply quantization pressure at eval time.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Quantized tensors.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="lingvo.core.quant_utils._CountedMinMaxAccumulator">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">lingvo.core.quant_utils.</span></span><span class="sig-name descname"><span class="pre">_CountedMinMaxAccumulator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dtype</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/quant_utils.html#_CountedMinMaxAccumulator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lingvo.core.quant_utils._CountedMinMaxAccumulator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="lingvo.core.base_layer.html#lingvo.core.base_layer.Accumulator" title="lingvo.core.base_layer.Accumulator"><code class="xref py py-class docutils literal notranslate"><span class="pre">lingvo.core.base_layer.Accumulator</span></code></a></p>
<p>Accumulator for a counted min/max.</p>
<p>Represented as a tensor of shape [count, min, max]. Every update
increases the count and expands the min/max (initially zeros).</p>
<dl class="py method">
<dt class="sig sig-object py" id="lingvo.core.quant_utils._CountedMinMaxAccumulator.DefaultValue">
<span class="sig-name descname"><span class="pre">DefaultValue</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/quant_utils.html#_CountedMinMaxAccumulator.DefaultValue"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lingvo.core.quant_utils._CountedMinMaxAccumulator.DefaultValue" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lingvo.core.quant_utils._CountedMinMaxAccumulator.Update">
<span class="sig-name descname"><span class="pre">Update</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">new_value</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/quant_utils.html#_CountedMinMaxAccumulator.Update"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lingvo.core.quant_utils._CountedMinMaxAccumulator.Update" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="lingvo.core.quant_utils.PassiveAsymQDomain">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">lingvo.core.quant_utils.</span></span><span class="sig-name descname"><span class="pre">PassiveAsymQDomain</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/quant_utils.html#PassiveAsymQDomain"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lingvo.core.quant_utils.PassiveAsymQDomain" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#lingvo.core.quant_utils.QDomain" title="lingvo.core.quant_utils.QDomain"><code class="xref py py-class docutils literal notranslate"><span class="pre">lingvo.core.quant_utils.QDomain</span></code></a></p>
<p>A quantization domain that does passive, asymmetric quantization.</p>
<p>See: <a class="reference external" href="https://arxiv.org/abs/1712.05877">https://arxiv.org/abs/1712.05877</a></p>
<p>This quantization domain will adjust to min/max ranges during training
time, recording them into vars via an exponential moving average and then
applying them at eval/inference time.</p>
<dl class="py method">
<dt class="sig sig-object py" id="lingvo.core.quant_utils.PassiveAsymQDomain.Params">
<em class="property"><span class="pre">classmethod</span> </em><span class="sig-name descname"><span class="pre">Params</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/quant_utils.html#PassiveAsymQDomain.Params"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lingvo.core.quant_utils.PassiveAsymQDomain.Params" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lingvo.core.quant_utils.PassiveAsymQDomain._CreateLayerVariables">
<span class="sig-name descname"><span class="pre">_CreateLayerVariables</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/quant_utils.html#PassiveAsymQDomain._CreateLayerVariables"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lingvo.core.quant_utils.PassiveAsymQDomain._CreateLayerVariables" title="Permalink to this definition">¶</a></dt>
<dd><p>Actually create variables for this layer.</p>
<p>Subclasses should override this function.</p>
<p>Variables are created inside of tf.variable_scope(self.params.name).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lingvo.core.quant_utils.PassiveAsymQDomain._MaybeFakeQuant">
<span class="sig-name descname"><span class="pre">_MaybeFakeQuant</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inputs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_v</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_v</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_bits</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/quant_utils.html#PassiveAsymQDomain._MaybeFakeQuant"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lingvo.core.quant_utils.PassiveAsymQDomain._MaybeFakeQuant" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="lingvo.core.quant_utils.PassiveAsymQDomain.bits">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">bits</span></span><a class="headerlink" href="#lingvo.core.quant_utils.PassiveAsymQDomain.bits" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieves the bits used by this quantization layer.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The number of bits available to this qdomain or None if unquantized.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lingvo.core.quant_utils.PassiveAsymQDomain.QuantizeWeight">
<span class="sig-name descname"><span class="pre">QuantizeWeight</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">w</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/quant_utils.html#PassiveAsymQDomain.QuantizeWeight"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lingvo.core.quant_utils.PassiveAsymQDomain.QuantizeWeight" title="Permalink to this definition">¶</a></dt>
<dd><p>Quantizes a weight.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>w</strong> – Weight tensor to quantize.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Quantized weight.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lingvo.core.quant_utils.PassiveAsymQDomain.QuantizeNaturalRange">
<span class="sig-name descname"><span class="pre">QuantizeNaturalRange</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_value</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_value</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/quant_utils.html#PassiveAsymQDomain.QuantizeNaturalRange"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lingvo.core.quant_utils.PassiveAsymQDomain.QuantizeNaturalRange" title="Permalink to this definition">¶</a></dt>
<dd><p>Quantizes a tensor with a known, natural range.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>t</strong> – Tensor to quantize.</p></li>
<li><p><strong>min_value</strong> – Min value of the range.</p></li>
<li><p><strong>max_value</strong> – Max value of the range.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Quantized tensor.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lingvo.core.quant_utils.PassiveAsymQDomain.QuantizeConstantRange">
<span class="sig-name descname"><span class="pre">QuantizeConstantRange</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_value</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_value</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/quant_utils.html#PassiveAsymQDomain.QuantizeConstantRange"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lingvo.core.quant_utils.PassiveAsymQDomain.QuantizeConstantRange" title="Permalink to this definition">¶</a></dt>
<dd><p>Quantizes a true-constant range that is not used for arithmetic.</p>
<p>This supports special values like padding that should have a precise
range that we do not deviate from.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>t</strong> – Tensor to quantize.</p></li>
<li><p><strong>min_value</strong> – Min of the range.</p></li>
<li><p><strong>max_value</strong> – Max of the range.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Quantized tensor.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lingvo.core.quant_utils.PassiveAsymQDomain.CreateTensor">
<span class="sig-name descname"><span class="pre">CreateTensor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t_name</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/quant_utils.html#PassiveAsymQDomain.CreateTensor"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lingvo.core.quant_utils.PassiveAsymQDomain.CreateTensor" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a QTensor with t_name.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>t_name</strong> – Unique name (within layer) for this tensor.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lingvo.core.quant_utils.PassiveAsymQDomain.QuantizeTensors">
<span class="sig-name descname"><span class="pre">QuantizeTensors</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ts</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eval_only</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/quant_utils.html#PassiveAsymQDomain.QuantizeTensors"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lingvo.core.quant_utils.PassiveAsymQDomain.QuantizeTensors" title="Permalink to this definition">¶</a></dt>
<dd><p>Quantizes a tensor with t_name previously created with CreateTensor.</p>
<p>If applicable, each of the passed tensors contributes to a shared
range.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>t_name</strong> – Tensor name.</p></li>
<li><p><strong>ts</strong> – List of tensors to quantize.</p></li>
<li><p><strong>eval_only</strong> – Whether to only apply quantization pressure at eval time.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Quantized tensors.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lingvo.core.quant_utils.PassiveAsymQDomain.GetTensorRange">
<span class="sig-name descname"><span class="pre">GetTensorRange</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ts</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/quant_utils.html#PassiveAsymQDomain.GetTensorRange"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lingvo.core.quant_utils.PassiveAsymQDomain.GetTensorRange" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieves the range of a tensor given the t_name used by CreateTensor.</p>
<p>Note, this computes the batch range across the list of tensors at training
time but fetches the stored tensor over time. This depends on
QuantizeTensors updating the appropriate value.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>t_name</strong> – Tensor name.</p></li>
<li><p><strong>ts</strong> – Tensor to determine the range for.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A min-max pair that represents the tensor range.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lingvo.core.quant_utils.PassiveAsymQDomain.PostTrainingStepUpdate">
<span class="sig-name descname"><span class="pre">PostTrainingStepUpdate</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/quant_utils.html#PassiveAsymQDomain.PostTrainingStepUpdate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lingvo.core.quant_utils.PassiveAsymQDomain.PostTrainingStepUpdate" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a TF op which will be invoked at each training step.</p>
<p>Subclasses of <code class="xref py py-obj docutils literal notranslate"><span class="pre">BaseLayer</span></code> can implement this method. The method should
return a TF op to be invoked during training after gradients are applied.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lingvo.core.quant_utils.PassiveAsymQDomain._CreateQStateVar">
<span class="sig-name descname"><span class="pre">_CreateQStateVar</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">suffix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/quant_utils.html#PassiveAsymQDomain._CreateQStateVar"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lingvo.core.quant_utils.PassiveAsymQDomain._CreateQStateVar" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lingvo.core.quant_utils.PassiveAsymQDomain._GetAccumulatorNameForTensor">
<span class="sig-name descname"><span class="pre">_GetAccumulatorNameForTensor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t_name</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/quant_utils.html#PassiveAsymQDomain._GetAccumulatorNameForTensor"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lingvo.core.quant_utils.PassiveAsymQDomain._GetAccumulatorNameForTensor" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lingvo.core.quant_utils.PassiveAsymQDomain._GetQStateVar">
<span class="sig-name descname"><span class="pre">_GetQStateVar</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">suffix</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/quant_utils.html#PassiveAsymQDomain._GetQStateVar"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lingvo.core.quant_utils.PassiveAsymQDomain._GetQStateVar" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lingvo.core.quant_utils.PassiveAsymQDomain._SummarizeTensor">
<span class="sig-name descname"><span class="pre">_SummarizeTensor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t_name</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/quant_utils.html#PassiveAsymQDomain._SummarizeTensor"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lingvo.core.quant_utils.PassiveAsymQDomain._SummarizeTensor" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lingvo.core.quant_utils.PassiveAsymQDomain._RecordTensor">
<span class="sig-name descname"><span class="pre">_RecordTensor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t_name</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/quant_utils.html#PassiveAsymQDomain._RecordTensor"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lingvo.core.quant_utils.PassiveAsymQDomain._RecordTensor" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lingvo.core.quant_utils._CopyShape">
<span class="sig-prename descclassname"><span class="pre">lingvo.core.quant_utils.</span></span><span class="sig-name descname"><span class="pre">_CopyShape</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">from_t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">to_t</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/quant_utils.html#_CopyShape"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lingvo.core.quant_utils._CopyShape" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the shape of from_t to to_t.</p>
</dd></dl>

</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="lingvo.core.recurrent.html" class="btn btn-neutral float-right" title="lingvo.core.recurrent module" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="lingvo.core.quant_test_lib.html" class="btn btn-neutral float-left" title="lingvo.core.quant_test_lib module" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2018.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>