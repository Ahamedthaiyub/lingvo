

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>lingvo.tasks.car.detection_3d_lib module &mdash; Lingvo  documentation</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="lingvo.tasks.car.detection_3d_metrics module" href="lingvo.tasks.car.detection_3d_metrics.html" />
    <link rel="prev" title="lingvo.tasks.car.car_lib module" href="lingvo.tasks.car.car_lib.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home" alt="Documentation Home"> Lingvo
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="lingvo.html">lingvo package</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="lingvo.html#subpackages">Subpackages</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="lingvo.core.html">lingvo.core package</a></li>
<li class="toctree-l3 current"><a class="reference internal" href="lingvo.tasks.html">lingvo.tasks package</a><ul class="current">
<li class="toctree-l4 current"><a class="reference internal" href="lingvo.tasks.html#subpackages">Subpackages</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="lingvo.tools.html">lingvo.tools package</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="lingvo.html#submodules">Submodules</a></li>
</ul>
</li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Lingvo</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="lingvo.html">lingvo package</a> &raquo;</li>
        
          <li><a href="lingvo.tasks.html">lingvo.tasks package</a> &raquo;</li>
        
          <li><a href="lingvo.tasks.car.html">lingvo.tasks.car package</a> &raquo;</li>
        
      <li>lingvo.tasks.car.detection_3d_lib module</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/lingvo.tasks.car.detection_3d_lib.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="module-lingvo.tasks.car.detection_3d_lib">
<span id="lingvo-tasks-car-detection-3d-lib-module"></span><h1>lingvo.tasks.car.detection_3d_lib module<a class="headerlink" href="#module-lingvo.tasks.car.detection_3d_lib" title="Permalink to this headline">¶</a></h1>
<p>Library of useful for functions for working with 3D object detection.</p>
<dl class="py class">
<dt id="lingvo.tasks.car.detection_3d_lib.Utils3D">
<em class="property">class </em><code class="sig-prename descclassname">lingvo.tasks.car.detection_3d_lib.</code><code class="sig-name descname">Utils3D</code><a class="reference internal" href="_modules/lingvo/tasks/car/detection_3d_lib.html#Utils3D"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.tasks.car.detection_3d_lib.Utils3D" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3.7/library/functions.html#object" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>Helper routines for 3D detection problems.</p>
<p>One common method to do 3D anchor box assignment is to match anchors to
ground-truth bboxes. First, we generate proposal anchors at given priors
(center locations, dimension prior, offset prior) to tile the input space.
After tiling the input space, each anchor can be assigned to a ground-truth
bbox by measuring IOU and taking a threshold. Note that a ground-truth bbox
may be assigned to multiple anchors - this is expected, and is managed at
inference time by non-max suppression.</p>
<p>Note: This implementation is designed to be used at input generation, and
does not support a batch dimension.</p>
<p>The following functions in this utility class helps with that:</p>
<blockquote>
<div><ul class="simple">
<li><p>CreateDenseCoordinates: Makes it easy to create a dense grid of
coordinates that would usually correspond to center locations.</p></li>
<li><p>MakeAnchorBoxes: Given a list of center coordinates, dimension priors, and
offset priors, this function creates actual anchor bbox parameters at each
coordinate. More than one box can be at each center.</p></li>
<li><p>IOUAxisAlignedBoxes: This function computes the IOU between two lists of
boxes.</p></li>
<li><p>AssignAnchors: This function assigns each anchor a ground-truth bbox. Note
that one ground-truth bbox can be assigned to multiple anchors. The model
is expected to regress the residuals each anchor and it’s corresponding
ground-truth bbox parameters.</p></li>
</ul>
</div></blockquote>
<dl class="py method">
<dt id="lingvo.tasks.car.detection_3d_lib.Utils3D.ScaledHuberLoss">
<code class="sig-name descname">ScaledHuberLoss</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">labels</span></em>, <em class="sig-param"><span class="n">predictions</span></em>, <em class="sig-param"><span class="n">weights</span><span class="o">=</span><span class="default_value">1.0</span></em>, <em class="sig-param"><span class="n">delta</span><span class="o">=</span><span class="default_value">1.0</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/tasks/car/detection_3d_lib.html#Utils3D.ScaledHuberLoss"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.tasks.car.detection_3d_lib.Utils3D.ScaledHuberLoss" title="Permalink to this definition">¶</a></dt>
<dd><p>Scaled Huber (SmoothL1) Loss.</p>
<p>This function wraps tf.losses.huber_loss to rescale it by 1 / delta, and
uses Reduction.NONE.</p>
<p>This scaling results in the following formulation instead:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">d</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">x</span><span class="o">^</span><span class="mi">2</span>       <span class="k">if</span> \<span class="o">|</span><span class="n">x</span>\<span class="o">|</span> <span class="o">&lt;=</span> <span class="n">d</span>
\<span class="o">|</span><span class="n">x</span>\<span class="o">|</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">d</span>         <span class="k">if</span> \<span class="o">|</span><span class="n">x</span>\<span class="o">|</span> <span class="o">&gt;</span> <span class="n">d</span>
</pre></div>
</div>
<p>where x is labels - predictions.</p>
<p>Hence, delta changes where the quadratic bowl is, but does not change the
overall shape of the loss outside of delta.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>labels</strong> – The ground truth output tensor, same dimensions as ‘predictions’.</p></li>
<li><p><strong>predictions</strong> – The predicted outputs.</p></li>
<li><p><strong>weights</strong> – Optional Tensor whose rank is either 0, or the same rank as
labels, and must be broadcastable to labels (i.e., all dimensions must
be either 1, or the same as the corresponding losses dimension).</p></li>
<li><p><strong>delta</strong> – float, the point where the huber loss function changes from a
quadratic to linear.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Weighted loss float Tensor. This has the same shape as labels.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="lingvo.tasks.car.detection_3d_lib.Utils3D.CornerLoss">
<code class="sig-name descname">CornerLoss</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">gt_bboxes</span></em>, <em class="sig-param"><span class="n">predicted_bboxes</span></em>, <em class="sig-param"><span class="n">symmetric</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/tasks/car/detection_3d_lib.html#Utils3D.CornerLoss"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.tasks.car.detection_3d_lib.Utils3D.CornerLoss" title="Permalink to this definition">¶</a></dt>
<dd><p>Corner regularization loss.</p>
<p>This function computes the corner loss, an alternative regression loss
for box residuals. This was used in the Frustum-PointNets paper [1].</p>
<p>We compute the predicted bboxes (all 8 corners) and compute a SmoothedL1
loss between the corners of the predicted boxes and ground truth. Hence,
this loss can help encourage the model to maximize the IoU of the
predictions.</p>
<dl class="simple">
<dt>[1] Frustum PointNets for 3D Object Detection from RGB-D Data</dt><dd><p><a class="reference external" href="https://arxiv.org/pdf/1711.08488.pdf">https://arxiv.org/pdf/1711.08488.pdf</a></p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>gt_bboxes</strong> – tf.float32 of shape […, 7] which contains (x, y, z, dx, dy,
dz, phi), corresponding to ground truth bbox parameters.</p></li>
<li><p><strong>predicted_bboxes</strong> – tf.float32 of same shape as gt_bboxes containing
predicted bbox parameters.</p></li>
<li><p><strong>symmetric</strong> – boolean.  If True, computes the minimum of the corner loss
with respect to both the gt box and the gt box rotated 180 degrees.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>tf.float32 Tensor of shape […] where each entry contains the corner loss
for the corresponding bbox.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="lingvo.tasks.car.detection_3d_lib.Utils3D.CreateDenseCoordinates">
<code class="sig-name descname">CreateDenseCoordinates</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ranges</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/tasks/car/detection_3d_lib.html#Utils3D.CreateDenseCoordinates"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.tasks.car.detection_3d_lib.Utils3D.CreateDenseCoordinates" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a matrix of coordinate locations corresponding to a dense grid.</p>
<p>Example: To create (x, y) coordinates corresponding over a 10x10 grid with
step sizes 1, call <code class="docutils literal notranslate"><span class="pre">CreateDenseCoordinates([(1,</span> <span class="pre">10,</span> <span class="pre">10),</span> <span class="pre">(1,</span> <span class="pre">10,</span> <span class="pre">10)])</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>ranges</strong> – A list of 3-tuples, each tuple is expected to contain (min, max,
num_steps). Each list element corresponds to one dimesion. Each tuple
will be passed into np.linspace to create the values for a single
dimension.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>tf.float32 tensor of shape [total_points, len(ranges)], where
total_points = product of all num_steps.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="lingvo.tasks.car.detection_3d_lib.Utils3D.MakeAnchorBoxes">
<code class="sig-name descname">MakeAnchorBoxes</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">anchor_centers</span></em>, <em class="sig-param"><span class="n">anchor_box_dimensions</span></em>, <em class="sig-param"><span class="n">anchor_box_offsets</span></em>, <em class="sig-param"><span class="n">anchor_box_rotations</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/tasks/car/detection_3d_lib.html#Utils3D.MakeAnchorBoxes"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.tasks.car.detection_3d_lib.Utils3D.MakeAnchorBoxes" title="Permalink to this definition">¶</a></dt>
<dd><p>Create anchor boxes from centers, dimensions, offsets.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>anchor_centers</strong> – [A, dims] tensor. Center locations to generate boxes at.</p></li>
<li><p><strong>anchor_box_dimensions</strong> – [B, dims] tensor corresponding to dimensions of
each box. The inner-most dimension of this tensor must match
anchor_centers.</p></li>
<li><p><strong>anchor_box_offsets</strong> – [B, dims] tensor corresponding to offsets of each box.</p></li>
<li><p><strong>anchor_box_rotations</strong> – [B] tensor corresponding to rotation of each box. If
None, rotation will be set to 0.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A [num_anchors_center, num_boxes_per_center, 2 * dims + 1] tensor. Usually
dims=3 for 3D, where <code class="docutils literal notranslate"><span class="pre">[...,</span> <span class="pre">:dims]</span></code> corresponds to location,
<code class="docutils literal notranslate"><span class="pre">[...,</span> <span class="pre">dims:2*dims]</span></code> corresponds to dimensions, and <code class="docutils literal notranslate"><span class="pre">[...,</span> <span class="pre">-1]</span></code>
corresponds to rotation.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="lingvo.tasks.car.detection_3d_lib.Utils3D.IOU2DRotatedBoxes">
<code class="sig-name descname">IOU2DRotatedBoxes</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">bboxes_u</span></em>, <em class="sig-param"><span class="n">bboxes_v</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/tasks/car/detection_3d_lib.html#Utils3D.IOU2DRotatedBoxes"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.tasks.car.detection_3d_lib.Utils3D.IOU2DRotatedBoxes" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes IoU between every pair of bboxes with headings.</p>
<p>This function ignores the z dimension, which is not usually considered
during anchor assignment.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>bboxes_u</strong> – tf.float32. [U, dims]. […, :7] are (x, y, z, dx, dy, dz, r).</p></li>
<li><p><strong>bboxes_v</strong> – tf.float32. [V, dims]. […, :7] are (x, y, z, dx, dy, dz, r).</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><dl class="simple">
<dt>tf.float32 tensor with shape [U, V], where [i, j] is IoU between</dt><dd><p>i-th bbox of bboxes_u and j-th bbox of bboxes_v.</p>
</dd>
</dl>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="lingvo.tasks.car.detection_3d_lib.Utils3D.AssignAnchors">
<code class="sig-name descname">AssignAnchors</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">anchor_bboxes</span></em>, <em class="sig-param"><span class="n">gt_bboxes</span></em>, <em class="sig-param"><span class="n">gt_bboxes_labels</span></em>, <em class="sig-param"><span class="n">gt_bboxes_mask</span></em>, <em class="sig-param"><span class="n">foreground_assignment_threshold</span><span class="o">=</span><span class="default_value">0.5</span></em>, <em class="sig-param"><span class="n">background_assignment_threshold</span><span class="o">=</span><span class="default_value">0.35</span></em>, <em class="sig-param"><span class="n">background_class_id</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">force_match</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">similarity_fn</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/tasks/car/detection_3d_lib.html#Utils3D.AssignAnchors"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.tasks.car.detection_3d_lib.Utils3D.AssignAnchors" title="Permalink to this definition">¶</a></dt>
<dd><p>Assigns anchors to bboxes using a similarity function (SSD-based).</p>
<p>Each anchor box is assigned to the top matching ground truth box.
Ground truth boxes can be assigned to multiple anchor boxes.</p>
<p>Assignments can result in 3 outcomes:</p>
<blockquote>
<div><ul class="simple">
<li><p>Positive assignment (if score &gt;= foreground_assignment_threshold):
assigned_gt_labels will reflect the assigned box label and
assigned_cls_mask will be set to 1.0</p></li>
<li><p>Background assignment (if score &lt;= background_assignment_threshold):
assigned_gt_labels will be background_class_id and assigned_cls_mask
will be set to 1.0</p></li>
<li><p>Ignore assignment (otherwise):
assigned_gt_labels will be background_class_id and assigned_cls_mask
will be set to 0.0</p></li>
</ul>
</div></blockquote>
<p>The detection loss function would usually:</p>
<blockquote>
<div><ul class="simple">
<li><p>Use assigned_cls_mask for weighting the classification loss. The mask
is set such that the loss applies to foreground and background
assignments only - ignored anchors will be set to 0.</p></li>
<li><p>Use assigned_reg_mask for weighting the regression loss. The mask is set
such that the loss applies to foreground assignments only.</p></li>
</ul>
</div></blockquote>
<p>The thresholds (foreground_assignment_threshold and
background_assignment_threshold) should be tuned per dataset.</p>
<p>TODO(jngiam): Consider having a separate threshold for regression boxes; a
separate threshold is used in PointRCNN.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>anchor_bboxes</strong> – tf.float32. [A, 7], where […, :] corresponds to box
parameters (x, y, z, dx, dy, dz, r).</p></li>
<li><p><strong>gt_bboxes</strong> – tf.float32. [G, 7], where […, :] corresponds to ground truth
box parameters (x, y, z, dx, dy, dz, r).</p></li>
<li><p><strong>gt_bboxes_labels</strong> – tensor with shape [G]. Ground truth labels for each
bounding box.</p></li>
<li><p><strong>gt_bboxes_mask</strong> – tensor with shape [G]. Mask for ground truth boxes, 1 iff
the gt_bbox is a real bbox.</p></li>
<li><p><strong>foreground_assignment_threshold</strong> – Similarity score threshold for assigning
foreground bounding boxes; scores need to be &gt;=
foreground_assignment_threshold to be assigned to foreground.</p></li>
<li><p><strong>background_assignment_threshold</strong> – Similarity score threshold for assigning
background bounding boxes; scores need to be &lt;=
background_assignment_threshold to be assigned to background.</p></li>
<li><p><strong>background_class_id</strong> – class id to be assigned to anchors_gt_class if no
anchor boxes match.</p></li>
<li><p><strong>force_match</strong> – Boolean specifying if force matching is enabled. If
force matching is enabled, then matched anchors which are also the
highest scoring with a ground-truth box are considered foreground
matches as long as their similarity score &gt; 0.</p></li>
<li><p><strong>similarity_fn</strong> – Function that computes the a similarity score (e.g., IOU)
between pairs of bounding boxes. This function should take in two
tensors corresponding to anchor and ground-truth bboxes, and return a
matrix [A, G] with the similarity score between each pair of bboxes. The
score must be non-negative, with greater scores representing more
similar. The fore/background_assignment_thresholds will be applied to
this score to determine if the an anchor is foreground, background or
ignored. If set to None, the function will default to IOU2DRotatedBoxes.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><p>NestedMap with the following keys</p>
<ul class="simple">
<li><p>assigned_gt_idx: shape [A] index corresponding to the index of the
assigned ground truth box. Anchors not assigned to a ground truth box
will have the index set to -1.</p></li>
<li><p>assigned_gt_bbox: shape [A, 7] bbox parameters assigned to each anchor.</p></li>
<li><p>assigned_gt_similarity_score: shape [A] (iou) score between the anchor
and the gt bbox.</p></li>
<li><p>assigned_gt_labels: shape [A] label assigned to bbox.</p></li>
<li><p>assigned_cls_mask: shape [A] mask for classification loss per anchor.
This should be 1.0 if the anchor has a foreground or background
assignment; otherwise, it will be assigned to 0.0.</p></li>
<li><p>assigned_reg_mask: shape [A] mask for regression loss per anchor.
This should be 1.0 if the anchor has a foreground assignment;
otherwise, it will be assigned to 0.0.
Note: background anchors do not have regression targets.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="lingvo.tasks.car.detection_3d_lib.Utils3D.LocalizationResiduals">
<code class="sig-name descname">LocalizationResiduals</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">anchor_bboxes</span></em>, <em class="sig-param"><span class="n">assigned_gt_bboxes</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/tasks/car/detection_3d_lib.html#Utils3D.LocalizationResiduals"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.tasks.car.detection_3d_lib.Utils3D.LocalizationResiduals" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the anchor residuals for every bbox.</p>
<p>For a given bbox, compute residuals in the following way:</p>
<blockquote>
<div><p>Let <code class="docutils literal notranslate"><span class="pre">anchor_bbox</span> <span class="pre">=</span> <span class="pre">(x_a,</span> <span class="pre">y_a,</span> <span class="pre">z_a,</span> <span class="pre">dx_a,</span> <span class="pre">dy_a,</span> <span class="pre">dz_a,</span> <span class="pre">phi_a)</span></code>
and <code class="docutils literal notranslate"><span class="pre">assigned_gt_bbox</span> <span class="pre">=</span> <span class="pre">(x_gt,</span> <span class="pre">y_gt,</span> <span class="pre">z_gt,</span> <span class="pre">dx_gt,</span> <span class="pre">dy_gt,</span> <span class="pre">dz_gt,</span> <span class="pre">phi_gt)</span></code></p>
<p>Define <code class="docutils literal notranslate"><span class="pre">diagonal_xy</span> <span class="pre">=</span> <span class="pre">sqrt(dx_a^2</span> <span class="pre">+</span> <span class="pre">dy_a^2)</span></code></p>
<p>Then the corresponding residuals are given by:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">x_residual</span> <span class="o">=</span> <span class="p">(</span><span class="n">x_gt</span> <span class="o">-</span> <span class="n">x_a</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">diagonal_xy</span><span class="p">)</span>
<span class="n">y_residual</span> <span class="o">=</span> <span class="p">(</span><span class="n">y_gt</span> <span class="o">-</span> <span class="n">y_a</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">diagonal_xy</span><span class="p">)</span>
<span class="n">z_residual</span> <span class="o">=</span> <span class="p">(</span><span class="n">z_gt</span> <span class="o">-</span> <span class="n">z_a</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">dz_a</span><span class="p">)</span>

<span class="n">dx_residual</span> <span class="o">=</span> <span class="n">log</span><span class="p">(</span><span class="n">dx_gt</span> <span class="o">/</span> <span class="n">dx_a</span><span class="p">)</span>
<span class="n">dy_residual</span> <span class="o">=</span> <span class="n">log</span><span class="p">(</span><span class="n">dy_gt</span> <span class="o">/</span> <span class="n">dy_a</span><span class="p">)</span>
<span class="n">dz_residual</span> <span class="o">=</span> <span class="n">log</span><span class="p">(</span><span class="n">dz_gt</span> <span class="o">/</span> <span class="n">dz_a</span><span class="p">)</span>

<span class="n">phi_residual</span> <span class="o">=</span> <span class="n">phi_gt</span> <span class="o">-</span> <span class="n">phi_a</span>
</pre></div>
</div>
<p>The normalization for x and y residuals by the diagonal was first
proposed by [1]. Intuitively, this reflects that objects can usually
move freely in the x-y plane, including diagonally. On the other hand,
moving in the z-axis (up and down) can be considered orthogonal to x-y.</p>
<p>For phi_residual, one way to frame the loss is with
SmoothL1(sine(phi_residual - phi_predicted)).
The use of sine to wrap the phi residual was proposed by [2]. This
stems from the observation that bboxes at phi and phi + pi are the same
bbox, fully overlapping in 3D space, except that the direction is
different. Note that the use of sine makes this residual invariant to
direction when a symmetric loss like SmoothL1 is used. In
ResidualsToBBoxes, we ensure that the phi predicted is between [0, pi).</p>
</div></blockquote>
<p>The Huber (SmoothL1) loss can then be applied to the delta between these
target residuals and the model predicted residuals.</p>
<dl class="simple">
<dt>[1] VoxelNet: End-to-End Learning for Point Cloud Based 3D Object Detection</dt><dd><p><a class="reference external" href="https://arxiv.org/abs/1711.06396">https://arxiv.org/abs/1711.06396</a></p>
</dd>
<dt>[2] SECOND: Sparsely Embedded Convolutional Detection</dt><dd><p><a class="reference external" href="https://pdfs.semanticscholar.org/5125/a16039cabc6320c908a4764f32596e018ad3.pdf">https://pdfs.semanticscholar.org/5125/a16039cabc6320c908a4764f32596e018ad3.pdf</a></p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>anchor_bboxes</strong> – tf.float32. where […, :7] contains (x, y, z, dx, dy, dz,
phi), corresponding to each anchor bbox parameters.</p></li>
<li><p><strong>assigned_gt_bboxes</strong> – tf.float32 of the same shape as anchor_bboxes
containing the corresponding assigned ground-truth bboxes.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A tf.float32 tensor of the same shape as anchor_bboxes with target
residuals for every corresponding bbox.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="lingvo.tasks.car.detection_3d_lib.Utils3D.ResidualsToBBoxes">
<code class="sig-name descname">ResidualsToBBoxes</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">anchor_bboxes</span></em>, <em class="sig-param"><span class="n">residuals</span></em>, <em class="sig-param"><span class="n">min_angle_rad</span><span class="o">=</span><span class="default_value">- 3.141592653589793</span></em>, <em class="sig-param"><span class="n">max_angle_rad</span><span class="o">=</span><span class="default_value">3.141592653589793</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/tasks/car/detection_3d_lib.html#Utils3D.ResidualsToBBoxes"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.tasks.car.detection_3d_lib.Utils3D.ResidualsToBBoxes" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts anchor_boxes and residuals to predicted bboxes.</p>
<p>This converts predicted residuals into bboxes using the following formulae:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">x_predicted</span> <span class="o">=</span> <span class="n">x_a</span> <span class="o">+</span> <span class="n">x_residual</span> <span class="o">*</span> <span class="n">diagonal_xy</span>
<span class="n">y_predicted</span> <span class="o">=</span> <span class="n">y_a</span> <span class="o">+</span> <span class="n">y_residual</span> <span class="o">*</span> <span class="n">diagonal_xy</span>
<span class="n">z_predicted</span> <span class="o">=</span> <span class="n">z_a</span> <span class="o">+</span> <span class="n">z_residual</span> <span class="o">*</span> <span class="n">dz_a</span>

<span class="n">dx_predicted</span> <span class="o">=</span> <span class="n">dx_a</span> <span class="o">*</span> <span class="n">exp</span><span class="p">(</span><span class="n">dx_residual</span><span class="p">)</span>
<span class="n">dy_predicted</span> <span class="o">=</span> <span class="n">dy_a</span> <span class="o">*</span> <span class="n">exp</span><span class="p">(</span><span class="n">dy_residual</span><span class="p">)</span>
<span class="n">dz_predicted</span> <span class="o">=</span> <span class="n">dz_a</span> <span class="o">*</span> <span class="n">exp</span><span class="p">(</span><span class="n">dz_residual</span><span class="p">)</span>

<span class="c1"># Adding the residual, and bounding it between</span>
<span class="c1"># [min_angle_rad, max_angle_rad]</span>
<span class="n">phi_predicted</span> <span class="o">=</span> <span class="n">NormalizeAngleRad</span><span class="p">(</span><span class="n">phi_a</span> <span class="o">+</span> <span class="n">phi_residual</span><span class="p">,</span>
                                  <span class="n">min_angle_rad</span><span class="p">,</span> <span class="n">max_angle_rad</span><span class="p">)</span>
</pre></div>
</div>
<p>These equations follow from those in LocalizationResiduals, where we solve
for the *_gt variables.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>anchor_bboxes</strong> – tf.float32. where […, :7] contains (x, y, z, dx, dy, dz,
phi), corresponding to each anchor bbox parameters.</p></li>
<li><p><strong>residuals</strong> – tf.float32 of the same shape as anchor_bboxes containing
predicted residuals at each anchor location.</p></li>
<li><p><strong>min_angle_rad</strong> – Scalar with the minimum angle allowed (before wrapping)
in radians.</p></li>
<li><p><strong>max_angle_rad</strong> – Scalar with the maximum angle allowed (before wrapping)
in radians. This value usually should be pi.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A tf.float32 tensor of the same shape as anchor_bboxes with predicted
bboxes.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="lingvo.tasks.car.detection_3d_lib.Utils3D.NMSIndices">
<code class="sig-name descname">NMSIndices</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">bboxes</span></em>, <em class="sig-param"><span class="n">scores</span></em>, <em class="sig-param"><span class="n">max_output_size</span></em>, <em class="sig-param"><span class="n">nms_iou_threshold</span><span class="o">=</span><span class="default_value">0.3</span></em>, <em class="sig-param"><span class="n">score_threshold</span><span class="o">=</span><span class="default_value">0.01</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/tasks/car/detection_3d_lib.html#Utils3D.NMSIndices"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.tasks.car.detection_3d_lib.Utils3D.NMSIndices" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply NMS to a series of 3d bounding boxes in 7-DOF format.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>bboxes</strong> – A [num_boxes, 7] floating point Tensor of bounding boxes in [x, y,
z, dx, dy, dz, phi] format.</p></li>
<li><p><strong>scores</strong> – A [num_boxes] floating point Tensor containing box
scores.</p></li>
<li><p><strong>max_output_size</strong> – Maximum number of boxes to predict per input.</p></li>
<li><p><strong>nms_iou_threshold</strong> – IoU threshold to use when determining whether two boxes
overlap for purposes of suppression.</p></li>
<li><p><strong>score_threshold</strong> – The score threshold passed to NMS that allows NMS to
quickly ignore irrelevant boxes.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The NMS indices and the mask of the padded indices.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="lingvo.tasks.car.detection_3d_lib.Utils3D.BatchedNMSIndices">
<code class="sig-name descname">BatchedNMSIndices</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">bboxes</span></em>, <em class="sig-param"><span class="n">scores</span></em>, <em class="sig-param"><span class="n">nms_iou_threshold</span><span class="o">=</span><span class="default_value">0.3</span></em>, <em class="sig-param"><span class="n">score_threshold</span><span class="o">=</span><span class="default_value">0.01</span></em>, <em class="sig-param"><span class="n">max_num_boxes</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/tasks/car/detection_3d_lib.html#Utils3D.BatchedNMSIndices"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.tasks.car.detection_3d_lib.Utils3D.BatchedNMSIndices" title="Permalink to this definition">¶</a></dt>
<dd><p>Batched version of NMSIndices.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>bboxes</strong> – A [batch_size, num_boxes, 7] floating point Tensor of bounding
boxes in [x, y, z, dx, dy, dz, phi] format.</p></li>
<li><p><strong>scores</strong> – A [batch_size, num_boxes, num_classes] floating point Tensor
containing box scores.</p></li>
<li><p><strong>nms_iou_threshold</strong> – IoU threshold to use when determining whether two boxes
overlap for purposes of suppression.</p></li>
<li><p><strong>score_threshold</strong> – The score threshold passed to NMS that allows NMS to
quickly ignore irrelevant boxes.</p></li>
<li><p><strong>max_num_boxes</strong> – The maximum number of boxes per example to emit. If None,
this value is set to num_boxes from the shape of bboxes.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The NMS indices and the mask of the padded indices for each example
in the batch.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="lingvo.tasks.car.detection_3d_lib.Utils3D.BatchedOrientedNMSIndices">
<code class="sig-name descname">BatchedOrientedNMSIndices</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">bboxes</span></em>, <em class="sig-param"><span class="n">scores</span></em>, <em class="sig-param"><span class="n">nms_iou_threshold</span></em>, <em class="sig-param"><span class="n">score_threshold</span></em>, <em class="sig-param"><span class="n">max_boxes_per_class</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/tasks/car/detection_3d_lib.html#Utils3D.BatchedOrientedNMSIndices"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.tasks.car.detection_3d_lib.Utils3D.BatchedOrientedNMSIndices" title="Permalink to this definition">¶</a></dt>
<dd><p>Runs batched version of a Per-Class 3D (7-DOF) Non Max Suppression.</p>
<p>All outputs have shape [batch_size, num_classes, max_boxes_per_class].</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>bboxes</strong> – A [batch_size, num_boxes, 7] floating point Tensor of bounding
boxes in [x, y, z, dx, dy, dz, phi] format.</p></li>
<li><p><strong>scores</strong> – A [batch_size, num_boxes, num_classes] floating point Tensor
containing box scores.</p></li>
<li><p><strong>nms_iou_threshold</strong> – Either a float or a list of floats of len num_classes
with the IoU threshold to use when determining whether two boxes overlap
for purposes of suppression.</p></li>
<li><p><strong>score_threshold</strong> – Either a float or a list of floats of len num_classes
with the score threshold that allows NMS to quickly ignore boxes.</p></li>
<li><p><strong>max_boxes_per_class</strong> – An integer scalar with the maximum number of boxes
per example to emit per class.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p>bbox_indices: An int32 Tensor with the indices of the chosen boxes.
Values are in sort order until the class_idx switches.</p></li>
<li><p>bbox_scores: A float32 Tensor with the score for each box.</p></li>
<li><p>valid_mask: A float32 Tensor with 1/0 values indicating the validity of
each box. 1 indicates valid, and 0 invalid.</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>A tuple of 3 tensors</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="lingvo.tasks.car.detection_3d_lib.Utils3D.CornersToImagePlane">
<code class="sig-name descname">CornersToImagePlane</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">corners</span></em>, <em class="sig-param"><span class="n">velo_to_image_plane</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/tasks/car/detection_3d_lib.html#Utils3D.CornersToImagePlane"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.tasks.car.detection_3d_lib.Utils3D.CornersToImagePlane" title="Permalink to this definition">¶</a></dt>
<dd><p>Project 3d box corners to the image plane.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>corners</strong> – A [batch, num_boxes, 8, 3] floating point tensor containing the 8
corners points for each 3d bounding box.</p></li>
<li><p><strong>velo_to_image_plane</strong> – A [batch, 3, 4] batch set of projection matrices from
velo xyz to image plane xy. After multiplication, you need to divide by
last coordinate to recover 2D pixel locations.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A [batch, num_boxes, 8, 2] floating point Tensor containing the 3D
bounding box corners projected to the image plane.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt id="lingvo.tasks.car.detection_3d_lib.RandomPadOrTrimTo">
<code class="sig-prename descclassname">lingvo.tasks.car.detection_3d_lib.</code><code class="sig-name descname">RandomPadOrTrimTo</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">tensor_list</span></em>, <em class="sig-param"><span class="n">num_points_out</span></em>, <em class="sig-param"><span class="n">seed</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/tasks/car/detection_3d_lib.html#RandomPadOrTrimTo"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.tasks.car.detection_3d_lib.RandomPadOrTrimTo" title="Permalink to this definition">¶</a></dt>
<dd><p>Pads or Trims a list of Tensors on the major dimension.</p>
<p>Slices if there are more points, or pads if not enough.</p>
<dl class="simple">
<dt>In this implementation:</dt><dd><p>Padded points are random duplications of real points.
Sliced points are a random subset of the real points.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tensor_list</strong> – A list of tf.Tensor objects to pad or trim along first dim. All
tensors are expected to have the same first dimension.</p></li>
<li><p><strong>num_points_out</strong> – An int for the requested number of points to trim/pad to.</p></li>
<li><p><strong>seed</strong> – Random seed to use for random generators.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><p>A tuple of output_tensors and a padding indicator.</p>
<ul class="simple">
<li><p>output_tensors: A list of padded or trimmed versions of our tensor_list
input tensors, all with the same first dimension.</p></li>
<li><p>padding: A tf.float32 tf.Tensor of shape [num_points_out] with 0 if the
point is real, 1 if it is padded.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="lingvo.tasks.car.detection_3d_metrics.html" class="btn btn-neutral float-right" title="lingvo.tasks.car.detection_3d_metrics module" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="lingvo.tasks.car.car_lib.html" class="btn btn-neutral float-left" title="lingvo.tasks.car.car_lib module" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2018

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>